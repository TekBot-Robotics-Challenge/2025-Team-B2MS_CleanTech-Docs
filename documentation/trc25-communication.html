<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css"
    />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles/style-commun.css" />
  <link rel="stylesheet" href="../styles/style-code.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/srcery.min.css">
  <link rel="icon" type="image/x-icon" href="../logo/favicon.ico">
  <title>R√©silience Urbaine - B2MS CleanTech</title>
</head>
<body>
  <header class="header">
    <div class="section__container header__container_domaine">
      <h2>R√©silience Urbaine</h2>
    </div>
  </header>

  <div class="layout-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="sidebar-toggle" id="sidebarToggle">
        <i class="fas fa-bars"></i>
      </div>

      <nav class="main-nav">
        <a href=".././" class="nav-link"><i class="fas fa-home"></i> Accueil</a>
        <a href="./it" class="nav-link"><i class="fas fa-desktop"></i> IT</a>
        <a href="./electronique" class="nav-link"><i class="fas fa-microchip"></i> √âlectronique</a>
        <a href="./ROS" class="nav-link"><i class="fas fa-cogs"></i> M√©canique</a>
        <a href="./convoyeur" class="nav-link"></i><i class="fas fa-forward"></i> Convoyeur</a>

        <div class="nav-section">
          <a href="./trc25" style="text-decoration: none;"><button class="tab-button active"><i class="fas fa-robot"></i> TRC25</button> </a>       
          <div class="sub-links">
            <a class="subtab-button" href="./trc25-convoyeur">Convoyeur 2.0</a>
            <a class="subtab-button" href="./trc25-dofbot">Prise en main du Dofbot</a>
            <a class="subtab-button active" href="./trc25-communication">Communication Dofbot - Convoyeur</a>
            <nav class="project-subnav active" id="subnav-communication">
              <a href="#1-communication">1. Communication I2C</a>
              <a href="#2-communication">2. Communication sans fil</a>
              <a href="#3-communication">3. Communication UART</a>
              <a href="#3-communication">4. Conclusion g√©n√©rale</a>
            </nav>
            <a class="subtab-button" href="./trc25-yolo">Mod√®le de d√©tection YOLO</a>
            <a class="subtab-button" href="./trc25-dofbot_ia">D√©tection et tri - Dofbot</a>
            <a class="subtab-button" href="./trc25-ros">ROS</a>
            <a class="subtab-button" href="./trc25-meca">Syst√®me de ramassage</a>
          </div>
        </div>

      </nav>
    </div>

    <!-- Contenu principal -->
    <main class="main-content">
      <section class="tab-content active">
        <div class="subtab-content active">
          <h2 id="communication" class="projet-titre">Communication Dofbot - Convoyeur</h2>
            <p>
              Le Dofbot est positionn√© en fin de convoyage afin d‚Äôassurer le tri des d√©chets transport√©s sur le convoyeur. 
              Lorsqu‚Äôun d√©chet atteint la zone finale du convoyeur, le syst√®me de convoyage doit notifier le Dofbot de sa pr√©sence 
              afin de permettre une prise en charge rapide et pr√©cise de l‚Äôobjet.
              <br>
              La performance globale du syst√®me repose en grande partie sur la qualit√©, la fiabilit√© et la rapidit√© de la communication entre ces deux sous-syst√®mes, 
              qui doivent fonctionner de mani√®re synchronis√©e pour garantir un tri efficace.
            </p>
            <p>
              Afin de garantir une interaction efficace et adapt√©e aux diff√©rents sc√©narios de fonctionnement, 
              trois types de communication ont √©t√© √©tudi√©s et test√©s :
              <ul>
                <li>communication I2C</li>
                <li>communication sans fil</li>
                <li>communication via une broche</li>
              </ul>
            </p>

          <h3 id="1-communication">1. Communication I2C</h3>
            <p>
              La communication I¬≤C (Inter-Integrated Circuit) est un protocole de communication s√©rie synchrone √† courte distance, 
              reposant sur une architecture <strong>ma√Ætre‚Äìesclave</strong>. 
              Dans ce syst√®me, le Dofbot joue le r√¥le de ma√Ætre, tandis que le convoyeur agit comme esclave.
            </p>
            <ul>
              Le bus I¬≤C repose sur deux lignes principales: 
              <li><strong>SDA</strong>(Serial Data) : ligne de donn√©es</li>
              <li><strong>SCL</strong>(Serial Clock) : ligne d‚Äôhorloge</li>
            </ul>

            <table>
              <thead>
                <tr>
                  <th>Avantages</th>
                  <th>Inconvenients</th>
                </tr>
              </thead>
              <tbody>
                  <td> 
                    <ul class="dash-list">
                      <li>C√¢blage r√©duit(trois fils dont deux de communication)</li>
                      <li>Bonne fiabilit√© pour des distances courtes</li>
                      <li>Communication bidirectionnelle</li>
                    </ul>
                  </td>
                  <td> 
                    <ul class="dash-list">
                      <li>Distance de communication limit√©e</li>
                      <li>Sensibilit√© au bruit √©lectrique</li>
                      <li>D√©pendance au ma√Ætre</li>
                    </ul>
                  </td>
                </tr>
              </tbody>
            </table>
            
            <p>
              Les connexions entre le Dofbot et le convoyeur sont r√©alis√©es comme suit :
            </p>
            <table>
              <thead>
                <tr>
                  <th>Dofbot(Ma√Ætre)</th>
                  <th>Convoyeur(esclave)</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>SDA</td>
                  <td>SDA</td>
                </tr>
                <tr>
                  <td>SCL</td>
                  <td>SCL</td>
                </tr>
                <tr>
                  <td>GND</td>
                  <td>GND</td>
                </tr>
              </tbody>
            </table>
            <p>
              <strong>NB:</strong>Il est indispensable d‚Äôavoir une <strong>masse commune (GND)</strong> entre les deux syst√®mes afin d‚Äôassurer une r√©f√©rence √©lectrique identique et garantir le bon fonctionnement de la communication.
            </p>

            <h4>a. Adaptation de niveau logique</h4>
              <p>
                Le Dofbot fonctionne avec un niveau logique de 3,3V, tandis que le microcontr√¥leur du convoyeur (Arduino) utilise des niveaux logiques de 5V. 
                Cette diff√©rence de tension peut entra√Æner des erreurs de communication, voire endommager les composants.
                <br>
                Pour assurer une communication fiable et s√©curis√©e, un <strong>convertisseur de niveau logique bidirectionnel</strong> est utilis√© entre les lignes SDA et SCL(Voir section <strong>Convoyeur 2.0</strong>). 
                Ce dispositif permet :
                <ul>
                  <li>d‚Äôadapter les niveaux de tension entre 3,3 V et 5 V,</li>
                  <li>de prot√©ger les entr√©es/sorties des deux syst√®mes,</li>
                  <li>de garantir l‚Äôint√©grit√© des signaux I¬≤C.</li>
                </ul>
              </p>

          <h4>b. Programmation</h4>
              <p>
                Afin d‚Äô√©tablir la communication I¬≤C, il est n√©cessaire de conna√Ætre l‚Äôadresse I¬≤C de l‚Äôesclave. 
                Cette adresse permet au ma√Ætre, en l‚Äôoccurrence le Dofbot, d‚Äôidentifier correctement le microcontr√¥leur du convoyeur (Arduino) sur le bus I¬≤C.
                <br>
                La d√©tection de cette adresse peut √™tre effectu√©e c√¥t√© Dofbot √† l‚Äôaide d‚Äôun scan du bus I¬≤C, en ex√©cutant la commande suivante :
                <div class="code-container">
                  <div class="btn-bar">
                    <button onclick="copierCode('scan_i2c', this)">üìã</button>
                  </div>
                  <pre><code class="hljs" id="scan_i2c">
i2cdetect -y -r -a 1
                  </code></pre>
                </div>      
              </p>

              <p>
                Ayant identifi√© l‚Äôadresse I¬≤C de l‚Äôesclave, le Dofbot peut alors √©tablir la communication et envoyer des commandes ou recevoir des informations en utilisant le protocole I¬≤C. 
                Le code suivant illustre l‚Äôinitialisation de la communication I¬≤C, l‚Äôenvoi d‚Äôune commande simple depuis le Dofbot vers le microcontr√¥leur du convoyeur, 
                ainsi que la r√©ception de la r√©ponse envoy√©e par l‚Äôesclave.
              </p>

              <details class="code-container">
                <summary>i2c_dofbot.py</summary>
                <div class="btn-bar">
                  <button onclick="copierCode('i2c_dofbot-py', this)">üìã</button>
                  <button onclick="telechargerCode('i2c_dofbot-py', 'i2c_dofbot.py', 'text/py', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="i2c_dofbot-py">
import smbus   #bibliotheque i2c
import time

# Bus I2C du Jetson
bus = smbus.SMBus(1)
ARDUINO_ADDR = 0x15


def send_command_and_read():
    try:
        #Envoyer une commande
        bus.write_byte(ARDUINO_ADDR, 5)
        print("Commande envoy√©e: 5")

        #Lire la r√©ponse de l'esclave (1 octet)
        time.sleep(1)  # petit d√©lai pour que l'Arduino pr√©pare la r√©ponse
        resp = bus.read_byte(ARDUINO_ADDR)
        print("R√©ponse re√ßue de l'Arduino:", resp)
    except Exception as e:
        print("Erreur I2C:", e)


while True:
    send_command_and_read()
    time.sleep(1)  #boucle toutes les secondes
                </code></pre>
              </details>

              <details class="code-container">
                <summary>i2c_convoyeur.ino</summary>
                <div class="btn-bar">
                  <button onclick="copierCode('i2c_convoyeur-ino', this)">üìã</button>
                  <button onclick="telechargerCode('i2c_convoyeur-ino', 'i2c_convoyeur.ino', 'text/ino', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="i2c_convoyeur-ino">
#include &lt;Wire.h&gt;   //biblioth√®que i2c

volatile byte lastCmd = 0;
volatile int reqCount = 0;

void setup() {
  Serial.begin(9600);
  Wire.begin(0x15); // adresse esclave
  Wire.onReceive(receiveEvent);
  Wire.onRequest(requestEvent);
}

void loop() {

}

void receiveEvent(int howMany) {
  while (Wire.available()) {
    lastCmd = Wire.read();
  }
  Serial.print("Donn√©e recue : ");
  Serial.println(lastCmd);
}

void requestEvent() {
  int data = 2;          // donn√©e envoy√©e

  Wire.write(data);         // envoi I2C
  reqCount++;

  Serial.print("Requete n¬∞ : ");
  Serial.println(reqCount);
  Serial.print("Envoy√© au ma√Ætre : ");
  Serial.println(data);
  Serial.println("------------------------------------");
}    
                </code></pre>
              </details>
              
          <!-- Video avec label -->
            <figure>
              <video controls width=auto>
                <source src="../videos/TRC25/Convoyeur/communication_i2c.mp4" type="video/mp4">
                Votre navigateur ne supporte pas la vid√©o HTML5.
              </video>
              <!-- <p class="txt_center">label</p> -->
            </figure>
            <p>
              Les r√©sultats exp√©rimentaux montrent que la transmission des donn√©es du Dofbot vers le convoyeur est fonctionnelle. 
              Toutefois, la r√©ception des donn√©es √©mises par l‚Äôesclave vers le ma√Ætre n‚Äôaboutit pas, 
              la valeur retourn√©e √©tant syst√©matiquement nulle.  
            </p>
            <p>
              Plusieurs tests ont √©t√© r√©alis√©s dans le but de d√©terminer la cause du dysfonctionnement observ√©. 
              La communication entre le convoyeur et un autre microcontr√¥leur Arduino a notamment √©t√© valid√©e, 
              confirmant le <strong>bon fonctionnement de l‚Äôesclave I¬≤C</strong>.
              Les connexions mat√©rielles ont √©t√© rev√©rifi√©es, 
              un d√©lai de r√©ponse a √©t√© introduit dans le code, et les broches de communication ont √©t√© modifi√©es 
              afin d‚Äô√©carter toute erreur li√©e au c√¢blage ou √† la configuration mat√©rielle.
              <br>
              Malgr√© ces ajustements, le probl√®me persiste. 
              Il appara√Æt donc que <strong>le dysfonctionnement soit li√© √† la r√©ception des donn√©es au niveau du Dofbot</strong>.
            </p>

          <h3 id="2-communication">2. Communication sans fil</h3>
            <p>
              Afin de contourner les limitations rencontr√©es avec la communication I¬≤C, une communication sans fil a √©t√© mise en place en parall√®le, 
              entre le Dofbot et le convoyeur, √† l‚Äôaide du <strong>module ESP-01 (ESP8266)</strong>.
              Cette approche permet d‚Äôassurer <strong>un √©change de donn√©es bidirectionnel</strong>, <strong>sans liaison filaire</strong>, 
              tout en offrant une plus grande flexibilit√© d‚Äôint√©gration .
            </p>
            <p>
              Le module ESP-01 est bas√© sur le microcontr√¥leur <strong>ESP8266</strong>, int√©grant <strong>une interface Wi-Fi</strong> et supportant <strong>les protocoles TCP/IP</strong>. 
              Il permet ainsi l‚Äôenvoi et la r√©ception de donn√©es via un r√©seau local sans fil.
            </p>

            <ul>
              L‚Äôarchitecture retenue repose sur une communication client‚Äìserveur :
              <li>Dofbot : serveur Wi-Fi</li>
              <li>Convoyeur : client Wi-Fi</li>
            </ul>
            <p>
              Le convoyeur notifie le Dofbot lorsqu‚Äôun d√©chet est d√©tect√© en fin de convoyage. 
              Le Dofbot analyse cette information et d√©clenche l‚Äôaction de tri appropri√©e.
            </p>

            <table>
              <thead>
                <tr>
                  <th>Avantages</th>
                  <th>Inconvenients</th>
                </tr>
              </thead>
              <tbody>
                  <td> 
                    <ul class="dash-list">
                      <li>Suppression des contraintes de c√¢blage</li>
                      <li>Communication bidirectionnelle fiable</li>
                      <li>Plus grande port√©e</li>
                    </ul>
                  </td>
                  <td> 
                    <ul class="dash-list">
                      <li>Communication bidirectionnelle fiable</li>
                      <li>D√©pendance √† la qualit√© du r√©seau Wi-Fi</li>
                      <li>Complexit√© logicielle plus √©lev√©e</li>
                    </ul>
                  </td>
                </tr>
              </tbody>
            </table>

            <p>
              <strong>NB:</strong> Le convoyeur(ESP-01 reli√© en UART avec l'arduino) et le dofbot doivent √™tre connect√©s au m√™me r√©seau Wi-Fi afin de permettre l‚Äô√©change de donn√©es.
            </p>

            <h4>a. Adaptation de niveau logique</h4>
              <p>
                Tout comme le dofbot, l'ESP-01 fonctionne avec un niveau logique de 3,3V. 
                Un convertisseur de niveau logique est donc n√©cessaire.(Voir section <strong>Convoyeur 2.0</strong>). 
              </p>

          <h4>b. Programmation</h4>
            <p>
              La programmation du syst√®me sans fil se divise en trois parties distinctes, correspondant aux diff√©rents composants impliqu√©s :
                <ul>
                  <li>
                    ESP-01: reli√© √† l‚ÄôArduino via UART, il g√®re la communication avec le Dofbot en tant que client Wi-Fi.
                  </li>
                  <li>
                    Arduino: interface avec les capteurs et actionneurs, envoi des donn√©es du convoyeur via l‚ÄôESP-01.
                  </li>
                  <li>
                    Dofbot: agit comme point d‚Äôacc√®s Wi-Fi (AP) et re√ßoit les notifications du convoyeur pour le tri des d√©chets.
                  </li>
                </ul>
              </p>

              <details class="code-container">
                <summary>esp_01.ino</summary>
                <div class="btn-bar">
                  <button onclick="copierCode('esp_01-ino', this)">üìã</button>
                  <button onclick="telechargerCode('esp_01-ino', 'esp_01.ino', 'text/ino', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="esp_01-ino">
#include &lt;ESP8266WiFi.h&gt;
#include &lt;ESP8266HTTPClient.h&gt;

const char* ssid = "Dofbot";
const char* password = "TRC25_b2ms";

const char* dofbotIP = "192.168.1.11";
int dofbotPort = 5001;                

WiFiClient client;

void setup() {
  Serial.begin(9600);

  WiFi.begin(ssid, password);
  // Serial.println("Connexion to Dofbot...");

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    // Serial.print(".");
  }

  // Serial.println("\nConnected to Wi-Fi !");
  // Serial.print("IP ESP : ");
  // Serial.println(WiFi.localIP());

  connectToDofbot();   // Connexion TCP
}

void loop() {
  if (!client.connected()) {
    // Serial.println("Reconnexion...");
    connectToDofbot();
  }

  if (Serial.available()) {
    String data = Serial.readStringUntil('\n'); // Re√ßoit la donn√©e depuis Arduino
    data.trim();

    if (data.length() > 0) {
      sendToDofbot(data);
    }
  }

  while (client.available()) {
    String response = client.readStringUntil('\n');
    response.trim();

    if (response.length() > 0) {
      Serial.println(response);   // Envoi vers Arduino
    }
  }
}

void connectToDofbot() {
  if (client.connect(dofbotIP, dofbotPort)) {
    // Serial.println("TCP connected to Dofbot!");
  } else {
    // Serial.println("TCP connection failed!");
  }
}

void sendToDofbot(String cmd) {
  if (client.connected()) {
    client.print(cmd);
    // Serial.println("Sent to Dofbot: " + cmd);
  } 
}
                </code></pre>
              </details>

              <details class="code-container">
                <summary>tcp_arduino.ino</summary>
                <div class="btn-bar">
                  <button onclick="copierCode('tcp_arduino-ino', this)">üìã</button>
                  <button onclick="telechargerCode('tcp_arduino-ino', 'tcp_arduino.ino', 'text/ino', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="tcp_arduino-ino">
#include &lt;SoftwareSerial.h&gt;

// RX, TX
SoftwareSerial espSerial(4, 7);

#define pinStart 2

#define LED_R 9
#define LED_G 10
#define LED_B 11

unsigned long lastInterrupt = 0;
volatile bool is_on = false;

// variables pour gestion du timing
unsigned long previousMillis = 0;
int colorState = 0;
const unsigned long interval = 2000; // intervalle de 2 secondes

void setup()
{
    Serial.begin(9600);        // PC
    espSerial.begin(9600);     // ESP

    pinMode(LED_R, OUTPUT);
    pinMode(LED_G, OUTPUT);
    pinMode(LED_B, OUTPUT);
    setColor(0, 0, 0); // √©teint la LED

    pinMode(pinStart, INPUT);
    attachInterrupt(digitalPinToInterrupt(pinStart), interrupt_routine, CHANGE);

    delay(500);
    is_on = digitalRead(pinStart);
}

void loop() {
    unsigned long currentMillis = millis();

    if (is_on) {
        if (currentMillis - previousMillis >= interval) {
            previousMillis = currentMillis;

            // changer la couleur en fonction de colorState
            switch(colorState) {
                case 0:
                    setColor(250, 0, 0); // rouge
		            espSerial.write("rouge");
                    Serial.println("Sent: rouge");
                    break;
                case 1:
                    setColor(0, 250, 0); // vert
		            espSerial.write("vert");
                    Serial.println("Sent: vert");
                    break;
                case 2:
                    setColor(0, 0, 250); // bleu
		                espSerial.write("bleu");
                    Serial.println("Sent: bleu");
                    break;
            }

            colorState++;
            if (colorState > 2) colorState = 0;
        }
    } else {
        setColor(0, 0, 0); // LED √©teinte
        previousMillis = currentMillis; // r√©initialiser le timing
        colorState = 0;
    }
}

void setColor(unsigned int red, unsigned int green, unsigned int blue)
{
    red = map(red, 0, 255, 255, 0);
    green = map(green, 0, 255, 255, 0);
    blue = map(blue, 0, 255, 255, 0);
    analogWrite(LED_R, red);
    analogWrite(LED_G, green);
    analogWrite(LED_B, blue);
}

void interrupt_routine() {
    unsigned long currentMillis = millis();
    detachInterrupt(digitalPinToInterrupt(pinStart)); 
    if (currentMillis - lastInterrupt > 200) { // anti-rebond 100ms
      is_on = digitalRead(pinStart);
      lastInterrupt = currentMillis;
    }
   attachInterrupt(digitalPinToInterrupt(pinStart), interrupt_routine, CHANGE);
}
                </code></pre>
              </details>

              <details class="code-container">
                <summary>tcp_dofbot.py</summary>
                <div class="btn-bar">
                  <button onclick="copierCode('tcp_dofbot-py', this)">üìã</button>
                  <button onclick="telechargerCode('tcp_dofbot-py', 'tcp_dofbot.py', 'text/py', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="tcp_dofbot-py">
import socket

HOST = '0.0.0.0'
PORT = 5001

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(1)

print("Serveur TCP pr√™t sur port", PORT)

while True:
    conn, addr = server.accept()
    print("Connexion :", addr)
    
    while True:
        data = conn.recv(1024)
        if not data:
            break
        cmd = data.decode().strip()
        print("Commande re√ßue :", cmd)

        # >>> ICI tu mets la fonction de mouvement du Dofbot <<<
        # move_robot(cmd)

    conn.close()
    print("Client d√©connect√©")
                </code></pre>
              </details>
              
          <!-- Video avec label -->
            <figure>
              <video controls width=auto>
                <source src="../videos/TRC25/Convoyeur/communication_tcp.mp4" type="video/mp4">
                Votre navigateur ne supporte pas la vid√©o HTML5.
              </video>
            </figure>

            <p>
              La communication sans fil entre le Dofbot et le convoyeur est fonctionnelle. 
              Les √©changes de donn√©es via les modules ESP-01 se d√©roulent correctement, permettant au Dofbot de recevoir les notifications du convoyeur.
            </p>

          <h3 id="3-communication">3. Communication UART</h3>
            <p>
              La communication UART (Universal Asynchronous Receiver Transmitter) repose sur une liaison s√©rie asynchrone point √† point entre deux syst√®mes. 
              Elle permet l‚Äô√©change de donn√©es sans horloge partag√©e, 
              la synchronisation √©tant assur√©e par des param√®tres de communication communs.
              <br>
              Dans ce projet, la communication UART est √©tablie directement entre le convoyeur et le Jetson Nano, 
              assurant une transmission simple, rapide et fiable des informations n√©cessaires au fonctionnement du syst√®me de tri.
            </p>

            <table>
              <thead>
                <tr>
                  <th>Avantages</th>
                  <th>Inconvenients</th>
                </tr>
              </thead>
              <tbody>
                  <td> 
                    <ul class="dash-list">
                      <li>Mise en ≈ìuvre simple</li>
                      <li>Communication stable et fiable</li>
                      <li>Faible latence</li>
                    </ul>
                  </td>
                  <td> 
                    <ul class="dash-list">
                      <li>Port√©e limit√©e par la longueur du c√¢ble</li>
                      <li>Communication point √† point uniquement</li>
                      <li>D√©pendance √† la connexion physique</li>
                    </ul>
                  </td>
                </tr>
              </tbody>
            </table>

            <h4>a. Connexion mat√©rielle</h4>
              <p>
                La liaison UART est r√©alis√©e √† l‚Äôaide d‚Äôun c√¢ble <strong>USB‚Äìs√©rie</strong>, reliant le microcontr√¥leur du convoyeur au Jetson. 
                Une fois connect√©, le p√©riph√©rique s√©rie est reconnu sous Linux sous la forme :
                <div class="code-container">
                  <div class="btn-bar">
                    <button onclick="copierCode('uart_connexion', this)">üìã</button>
                  </div>
                  <pre><code class="hljs" id="uart_connexion">
/dev/ttyUSB0
                  </code></pre>
                </div>
              </p>
              <p>
                Cette interface est utilis√©e par le programme ex√©cut√© sur le Jetson pour recevoir les donn√©es √©mises par le convoyeur.
              </p>

              <p>
                <strong>NB:</strong> 
                L‚Äôutilisation d‚Äôun c√¢ble USB‚Äìs√©rie garantit une <strong>adaptation automatique des niveaux logiques</strong> et <strong>simplifie l‚Äôint√©gration mat√©rielle</strong>.
              </p>

            <h4>b. Programmation</h4>
              <ul>
                Deux programmes ont √©t√© d√©velopp√©s afin de tester la communication UART filaire entre le convoyeur et le Jetson Nano (Dofbot) :
                <li>
                  <strong><em>uart_arduino.ino</em></strong> : 
                  ex√©cut√© sur l‚ÄôArduino du convoyeur, il permet l‚Äôenvoi p√©riodique d‚Äôun message via l‚Äôinterface UART.
                </li> 
                <li>
                  <strong><em>uart_dofbot.py</em></strong> : 
                  ex√©cut√© sur le Jetson Nano, il assure la r√©ception des donn√©es transmises par le convoyeur via le port s√©rie (/dev/ttyUSB0).
                </li> 
              </ul>

              <details class="code-container">
                <summary>uart_arduino.ino</summary>
                <div class="btn-bar">
                  <button onclick="copierCode('tcp_arduino-ino', this)">üìã</button>
                  <button onclick="telechargerCode('tcp_arduino-ino', 'tcp_arduino.ino', 'text/ino', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="tcp_arduino-ino">
void setup()
{
    Serial.begin(9600);
    delay(1000);
}


void loop()
{
  Serial.println("hello");
delay(5000);
}
                </code></pre>
              </details>

              <details class="code-container">
                <summary>uart_dofbot.py</summary>
                <div class="btn-bar">
                  <button onclick="copierCode('tcp_dofbot-py', this)">üìã</button>
                  <button onclick="telechargerCode('tcp_dofbot-py', 'tcp_dofbot.py', 'text/py', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="tcp_dofbot-py">
import serial
import time

serial_port = "/dev/ttyUSB0"
baurate = 9600

try:
    arduino_data = serial.Serial(serial_port, baurate, timeout=1)
    time.sleep(2)
    print("Connexion √©tablie")
    while True:
        while(arduino_data.inWaiting()==0):
            pass
        data_packet = arduino_data.readline()
        data_packet = str(data_packet, "utf-8")
        data_packet = data_packet.strip('\r\n')
        print(data_packet)

except KeyboardInterrupt:
    print('Exiting Program')

except:
    print('Error Occurs, Exiting Program')
                </code></pre>
              </details>
              
              <p>
                Ces deux programmes permettent de tester la communication en envoyant le message "hello" depuis le convoyeur vers le Dofbot, validant ainsi le bon fonctionnement de la liaison UART.
              </p>

          <h3 id="4-communication">4. Conclusion g√©n√©rale</h3>
            <p>
              Dans le cadre de ce projet, trois types de communication entre le convoyeur et le Dofbot ont √©t√© √©tudi√©s, impl√©ment√©s et test√©s : 
              la communication I¬≤C, la communication sans fil via l‚ÄôESP-01 (Wi-Fi) et la communication UART filaire.  
            </p>

            <h4>a. Communication I2C</h4>
              <p>
                La communication I¬≤C, bien que th√©oriquement adapt√©e pour des √©changes rapides √† courte distance, n‚Äôa pas permis d‚Äôassurer une communication bidirectionnelle fonctionnelle dans le contexte de ce projet. 
                Malgr√© plusieurs tests et v√©rifications (c√¢blage, d√©lais, configuration logicielle), la r√©ception des donn√©es au niveau du Dofbot est rest√©e non fonctionnelle.
                Cette communication n'est donc pas retenue.
              </p>

            <h4>b. Communication sans fil</h4>
              <p>
                La communication sans fil via l‚ÄôESP-01 s‚Äôest r√©v√©l√©e fonctionnelle et a permis un √©change bidirectionnel de donn√©es entre le convoyeur et le Dofbot. 
                Toutefois, cette solution introduit une latence li√©e au r√©seau Wi-Fi ainsi qu‚Äôune complexit√© logicielle plus √©lev√©e, ce qui peut constituer un inconv√©nient pour des actions n√©cessitant une r√©ponse imm√©diate.
                <br>
                Malgr√© ces contraintes, un code de communication TCP a √©t√© d√©velopp√© et test√© c√¥t√© Dofbot afin de valider le fonctionnement global de cette approche. 
                Ce programme met en ≈ìuvre un serveur TCP, capable de recevoir les notifications envoy√©es par le convoyeur (via l‚ÄôESP-01), de d√©tecter la pr√©sence d‚Äôun objet et de g√©rer un timeout en cas d‚Äôabsence de nouvelles donn√©es.
              </p>
              <p>
                Le code suivant illustre l‚Äôimpl√©mentation du serveur TCP ex√©cut√© sur le Dofbot :
              </p>
              <details class="code-container">
                <summary>tcp_server.py</summary>
                <div class="btn-bar">
                  <button onclick="copierCode('tcp_server-py', this)">üìã</button>
                  <button onclick="telechargerCode('tcp_server-py', 'tcp_server.py', 'text/py', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="tcp_server-py">
#!/usr/bin/env python
# coding: utf-8

import socket
import time


class tcp_Server:
    def __init__(self, host='0.0.0.0', port=5001, timeout=2.5):
        self.host = host
        self.port = port
        self.timeout = timeout

        self.server = None
        self.conn = None
        self.addr = None

        self.presence = False
        self.last_msg_time = 0

    def start_server(self):
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind((self.host, self.port))
        self.server.listen(1)

        print(f"Serveur TCP pr√™t sur {self.host}:{self.port}")
        self.conn, self.addr = self.server.accept()
        print("Connexion Arduino :", self.addr)

        self.conn.setblocking(False)

    def listen(self):
        try:
            data = self.conn.recv(1024)
            if data:
                cmd = data.decode().strip()
                if cmd == "piece":
                    self.presence = True
                    self.last_msg_time = time.time()
        except BlockingIOError:
            pass

        if self.presence:
            if time.time() - self.last_msg_time > self.timeout:
                self.presence = False

    def close(self):
        if self.conn:
            self.conn.close()
        if self.server:
            self.server.close()
                </code></pre>
              </details>

            <h4>c. Communication UART</h4>
              <p>
                La communication UART filaire entre le convoyeur et le Jetson Nano s‚Äôest r√©v√©l√©e simple, fiable et rapide, r√©pondant efficacement aux besoins de transmission des informations critiques du syst√®me. 
                Contrairement √† la communication sans fil, cette solution ne d√©pend pas d‚Äôun r√©seau et ne pr√©sente qu‚Äôune latence n√©gligeable, ce qui la rend particuli√®rement adapt√©e aux actions n√©cessitant une r√©ponse imm√©diate.
                <br>
                Dans ce cadre, un code de communication UART a √©t√© d√©velopp√© c√¥t√© Jetson Nano afin de valider le bon fonctionnement de cette liaison.
              </p>
                
              <details class="code-container">
                <summary>uart_Arduino.py</summary>
                <div class="btn-bar">
                  <button onclick="copierCode('uart_Arduino-py', this)">üìã</button>
                  <button onclick="telechargerCode('uart_Arduino-py', 'uart_Arduino.py', 'text/py', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="uart_Arduino-py">
#!/usr/bin/env python
# coding: utf-8

import serial
import time

class uart_Arduino:
    def __init__(self, serial_port="/dev/ttyUSB0", baudrate=9600, timeout=2.5):
        self.serial_port = serial_port
        self.baudrate = baudrate
        self.timeout = timeout

        self.arduino = None
        self.presence = False
        self.last_msg_time = 0

    def start(self):
        try:
            self.arduino = serial.Serial(self.serial_port, self.baudrate, timeout=1)
            time.sleep(2)  # temps pour l'initialisation de l'Arduino
            print(f"Connexion UART √©tablie sur {self.serial_port} √† {self.baudrate} bauds")
        except Exception as e:
            print(f"Erreur de connexion UART : {e}")

    def listen(self):
        if self.arduino and self.arduino.in_waiting > 0:
            try:
                data = self.arduino.readline().decode().strip()
                if data == "piece":
                    self.presence = True
                    self.last_msg_time = time.time()
            except Exception as e:
                print(f"Erreur lecture UART : {e}")

        # Timeout pour remettre presence √† False
        if self.presence and (time.time() - self.last_msg_time > self.timeout):
            self.presence = False

    def close(self):
        if self.arduino:
            self.arduino.close()
            print("UART ferm√©e")
                </code></pre>
              </details>
            
            <h4>d. Conclusion</h4>
              <p>
                En conclusion, la communication UART filaire a √©t√© retenue comme solution principale pour ce projet, 
                tandis que la communication sans fil constitue une alternative flexible et √©volutive. 
                La communication I¬≤C, quant √† elle, n‚Äôa pas √©t√© retenue en raison de son manque de fiabilit√© dans cette configuration.
              </p>

              

        </div>
      </section>
    </main>
  </div> 

  <footer>
    Copyright ¬© 2025 Team B2MS CleanTech. All rights reserved.
  </footer>

  <script src="../scripts/script_commun.js"></script>
  <script src="../scripts/script_code.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</body>
</html>
