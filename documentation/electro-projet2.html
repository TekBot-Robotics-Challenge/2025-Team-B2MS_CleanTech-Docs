<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css"
    />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles/style-commun.css" />
  <link rel="stylesheet" href="../styles/style-code.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/srcery.min.css">
  <link rel="icon" type="image/x-icon" href="../logo/favicon.ico">
  <title>D√©partement √âlectronique</title>
</head>
<body>
  <header class="header">
    <div class="section__container header__container_domaine">
      <h2>D√©partement √âlectronique</h2>
    </div>
  </header>

  <div class="layout-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="sidebar-toggle" id="sidebarToggle">
        <i class="fas fa-bars"></i>
      </div>

      <nav class="main-nav">
        <a href=".././" class="nav-link"><i class="fas fa-home"></i> Accueil</a>

        <div class="nav-section">
          <a href="./it" class="nav-link"><i class="fas fa-desktop"></i> IT</a>
          <a href="./electronique" style="text-decoration: none;"><button class="tab-button active"><i class="fas fa-microchip"></i> √âlectronique</button> </a>       
          
          <div class="sub-links">
            <a href="./electro-projet1" class="subtab-button">Projet 1</a>
            <a class="subtab-button active" href="./electro-projet2">Projet 2</a>
              <nav class="project-subnav active" id="subnav-test2">
              <a href="#1-test2">1. Introduction</a>
              <a href="#2-test2">2. Cahier des charges</a>
              <a href="#3-test2">3. Sch√©ma synoptique</a>
              <a href="#4-test2">4. Description fonctionnelle</a>
              <a href="#5-test2">5. Etapes de validation</a>
              <a href="#6-test2">6. R√©alisation du PCB</a>
              <a href="#7-test2">7. Prototype</a>
            </nav>
            <a class="subtab-button" href="./electro-projet3">Projet 3</a>
          </div>
        </div>

        <a href="./mecanique" class="nav-link"><i class="fas fa-cogs"></i> M√©canique</a>
        <a href="./convoyeur" class="nav-link"></i><i class="fas fa-forward"></i> Convoyeur</a>
        <a href="./trc25" class="nav-link"><i class="fas fa-robot"></i> TRC25</a>
      </nav>
    </div>

    <!-- Contenu principal -->
    <main class="main-content">
      <section id="electro-content" class="tab-content active">
        <div id="test2" class="subtab-content active">
          <h2 id="projet2" class="projet-titre">Projet 2 - Bo√Æte noire</h2>
            <h3 id="1-test2">1. Introduction</h3>
            <p>
              Dans les syst√®mes embarqu√©s modernes, la collecte et l‚Äôanalyse de donn√©es 
              en temps r√©el sont essentielles pour le suivi et la s√©curit√© des √©quipements, 
              notamment dans des domaines critiques comme l‚Äôautomobile, l‚Äôaviation ou le 
              ferroviaire. S‚Äôinspirant du fonctionnement des bo√Ætes noires utilis√©es dans 
              ces industries, ce projet a pour objectif de concevoir un syst√®me embarqu√© 
              capable d‚Äôenregistrer et de transmettre en temps r√©el des donn√©es de mouvement 
              (vitesse et orientation) √† l‚Äôaide d‚Äôun capteur inertiel. 
              Les informations sont ensuite visualis√©es sur une station de contr√¥le via 
              un √©cran LCD. Ce projet s‚Äôinscrit dans le cadre du Tekbot Robotics Challenge 
              et fait appel √† plusieurs comp√©tences majeures : programmation directe des 
              microcontr√¥leurs ATmega328P sans utiliser de carte Arduino, communication via 
              le protocole I2C, conception de circuits imprim√©s avec KiCAD, r√©alisation 
              d‚Äôun bo√Ætier cubique de 7 cm, int√©gration mat√©rielle sur veroboard ou PCB,
              ainsi que la conception d‚Äôune alimentation sp√©cifique.
            </p>

            <h3 id="2-test2">2. Cahier des charges</h3>
              <h4>a. Objectifs fonctionnels</h4>
                <ul>
                  <li>Lire les donn√©es de vitesse et d‚Äôorientation √† l‚Äôaide du MPU6050</li>
                  <li>Utiliser le microcontr√¥leur ATmega328P sans carte Arduino</li>
                  <li>Concevoir un circuit imprim√© (PCB) et une alimentation autonome</li>
                  <li>Transmettre les donn√©es √† une station de contr√¥le via I2C</li>
                  <li>Afficher les donn√©es sur un √©cran LCD en mode 4 bits</li>
                </ul>

              <h4>b. Contraintes techniques</h4>
                <ul>
                  <li>Le cube doit mesurer 7x7x7 cm, avec une face ouverte pour voir le circuit</li>
                  <li>Le microcontr√¥leur du cube agit en ma√Ætre I2C</li>
                  <li>Le microcontr√¥leur de la station agit en esclave I2C</li>
                  <li>Alimentation externe obligatoire, hors du cube</li>
                  <li>Sch√©ma et PCB r√©alis√©s avec KiCad</li>
                </ul>
              <h4>c. Mat√©riels utilis√©s</h4>
                <ul>
                  <li><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf" target="_blank">ATmega328P</a> √ó2</li>
                  <li><a href="https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf" target="_blank">MPU6050</a></li>
                  <li><a href="https://www.gotronic.fr/pj2-sbc-lcd16x2-fr-1441.pdf?srsltid=AfmBOopmg8VyH8PQXxRcqE7GEvoyRwGRHeKVU9ZsKwGmKu13oZXhPhaJ" target="_blank">LCD 16x2</a> (mode 4 bits)</li>
                  <li>Alimentation</li>
                </ul>

            <h3 id="3-test2">3. Sch√©ma synoptique</h3>
            <p>
              Ce syst√®me embarqu√© est compos√© de deux unit√©s :
              une <strong>bo√Æte noire</strong> et une <strong>station de contr√¥le</strong>, 
              connect√©es via le bus I2C.
              La bo√Æte noire comprend un capteur MPU6050 qui d√©tecte les mouvements de la main 
              et envoie les donn√©es √† un microcontr√¥leur ATmega328P configur√© en ma√Ætre. 
              Celui-ci traite les donn√©es et les transmet √† la station de contr√¥le, 
              o√π un autre ATmega328P, configur√© en esclave, les re√ßoit. 
              Les informations sont ensuite affich√©es sur un √©cran LCD.
              Chaque unit√© est aliment√©e s√©par√©ment par une source de 5V.
            </p>
            <div class="image-container">
                <img src="../images/Test2/Electronique/image1.webp" alt="Prototype"/>
            </div>

            <h3 id="4-test2">4. Description fonctionnelle des diff√©rents blocs du syst√®me</h3>
              <h4>a. Bloc d‚Äôalimentation</h4>
                <ul>
                  <li><strong>Fonction principale</strong></li>
                <p>
                  Ce bloc a pour objectif de fournir une tension continue et stable de 5V n√©cessaire 
                  au fonctionnement des diff√©rents composants √©lectroniques du syst√®me, 
                  notamment le capteur <strong>MPU6050</strong>, les <strong>microcontr√¥leurs ATmega328P</strong> et l'√©cran <strong>LCD</strong>.
                </p>

                  <li><strong>Fonctionnement</strong></li>
                <p>
                  On utilise trois batteries de Li-Ion 3,7V rechargeables mont√©es en s√©rie pour obtenir environ 12V.
                </p>
                <p>
                  Le <strong>r√©gulateur L7805</strong> re√ßoit ce 12V en entr√©e (Vin) et fournit du 5V en sortie (Vout).
                </p>
                <p>
                  Deux condensateurs (330nF <strong>√† l‚Äôentr√©e</strong> et 100nF <strong>√† la sortie</strong>) sont utilis√©s pour stabiliser la tension et filtrer les parasites:
                </p>
                <div class="image-container">
                  <img src="../images/Test2/Electronique/image2.webp" alt="schema"/>
                </div>
                <p>
                  La simulation sur proteus : Les condensateurs de filtrage ont √©t√© omis dans ce sch√©ma pour simplifier la repr√©sentation, bien qu‚Äôils soient indispensables en pratique pour assurer la stabilit√© et r√©duire le bruit.
                </p>
                <div class="image-container">
                  <img src="../images/Test2/Electronique/image3.webp" alt="schema"/>           
                </div>

                <video controls width=30%>
                  <source src="../videos/Test2/Electronique/test.mp4" type="video/mp4">
                  Votre navigateur ne supporte pas la vid√©o HTML5.                   
                </video>

                </ul>
              
              <h4>b. Bloc d‚Äôentr√©e(dans la boite noire)</h4>
              <p>
                Nous avons choisi le capteur MPU6050 parce qu‚Äôil int√®gre un acc√©l√©rom√®tre et un 
                gyroscope dans un seul composant. Cela permet de mesurer les mouvements et les rotations 
                de la main avec pr√©cision. Il est facile √† utiliser gr√¢ce au protocole I2C, et il fonctionne 
                bien avec le microcontr√¥leur ATmega328P. En plus, il est peu co√ªteux et largement utilis√© 
                dans les projets embarqu√©s. D‚Äôautres capteurs peuvent faire un travail similaire, comme le 
                MPU9250 (qui ajoute un magn√©tom√®tre), le LSM6DS3 (plus r√©cent et plus √©conome), ou le ADXL34
              </p>
              <div class="image-container">
                  <img src="../images/Test2/Electronique/image4.webp" alt="schema"/>
              </div>

              <h4>c. Bloc de commande(dans la boite noire)</h4>
                <ul>
                  <li><strong>√âtape 1 : Prise en main du microcontr√¥leur ATmega328P</strong></li>
                <p>
                  Avant de d√©marrer le syst√®me complet, l‚Äô√©quipe s‚Äôest d‚Äôabord focalis√©e sur le 
                  microcontr√¥leur ATmega328P. L‚Äôobjectif √©tait de comprendre pleinement sa structure 
                  interne, ses broches, ainsi que la mani√®re de le configurer et de le simuler.
                </p>
                <p>
                  Nous avons √©tudi√© ses principales caract√©ristiques et son brochage :
                </p>
                <ul>
                  <li>Le format DIP √† 28 broches, comme dans les cartes Arduino Uno</li>
                  <li>Les broches d‚ÄôE/S num√©riques D0 √† D13, pour piloter des LED, relais, etc.</li>
                  <li>Les entr√©es analogiques A0 √† A5, pour la lecture de capteurs</li>
                  <li>L‚Äôinterface I2C via SDA (PC4) et SCL (PC5)</li>
                  <li>La communication s√©rie UART via TX (PD1) et RX (PD0)</li>
                  <li>Les broches d‚Äôalimentation : VCC, GND, AVCC, AREF</li>
                  <li>La broche RESET, g√©n√©ralement tir√©e √† l‚Äô√©tat haut via une r√©sistance</li>
                  <li>Les broches XTAL1/XTAL2 pour le quartz (utilis√© plus tard)</li>
                </ul>
                <p>
                  Ces √©l√©ments nous ont permis de pr√©parer une simulation fiable sous Proteus 
                  pour la suite du projet.
                </p>
                <div class="image-container">
                  <img src="../images/Test2/Electronique/image5.webp" alt="schema"/>
                </div>

                  <li><strong>√âtape 2 : Simulation basique de l‚ÄôATmega328P dans Proteus</strong></li>
                <p>
                  Apr√®s avoir √©tudi√© la configuration du microcontr√¥leur, nous avons r√©alis√© une premi√®re 
                  simulation simple sous Proteus, afin de valider son fonctionnement dans un environnement 
                  simul√©.
                </p>
                <p>
                  √Ä ce stade :
                </p>
                <ul>
                  <li>Nous n'avons pas utilis√© les connexions d‚Äôalimentation (VCC/AVCC) ni de quartz externe, car elles ne sont pas obligatoires pour les logiques simples dans Proteus.</li>
                  <li>Nous nous sommes concentr√©s sur le comportement des broches dans un exemple r√©el.</li>
                </ul>
                <p>
                  Sc√©nario de simulation : Nous avons con√ßu un syst√®me simple dans lequel :
                </p>
                <ul>
                  <li>Un bouton poussoir est connect√© √† une entr√©e num√©rique.</li>
                  <li>
                    Nous nous sommes concentr√©s sur le comportement des broches dans un exemple r√©el. 
                    Lorsqu‚Äôon appuie sur le bouton, l‚ÄôATmega active un relais via une sortie num√©rique.
                  </li>
                  <li>Ce relais commande une lampe LED 12V, simulant une charge r√©elle.</li>
                </ul>
                <p>
                  Le code Arduino correspondant a √©t√© compil√© dans l‚ÄôIDE Arduino, puis le fichier .hex 
                  g√©n√©r√© a √©t√© int√©gr√© dans Proteus pour tester le comportement du circuit.
                </p>     
                <video controls width=60%>
                <source src="../videos/Test2/Electronique/video1.mp4" type="video/mp4">
                  Votre navigateur ne supporte pas la vid√©o HTML5.
                </video>

                <p>
                  Observation :
                </p>
                <ul>
                  <li>Lorsque le bouton est press√©, le relais s‚Äôactive et allume la LED.</li>
                  <li>Le comportement observ√© est conforme √† la logique attendue et coh√©rente.</li>
                </ul>
              </ul>

                <h4>d. Bloc d‚Äôaffichage de la station du controle</h4>
                <p>
                  Pour l‚Äôaffichage des donn√©es au niveau de la station de contr√¥le, nous avons opt√© pour 
                  un √©cran LCD √©quip√© d‚Äôun module I2C. Ce choix permet de simplifier le montage √©lectronique 
                  en r√©duisant consid√©rablement le nombre de connexions n√©cessaires entre le microcontr√¥leur 
                  et l‚Äô√©cran. Gr√¢ce √† cette interface, seules deux lignes (SDA et SCL) suffisent pour 
                  transmettre les informations, ce qui laisse davantage de broches disponibles pour d‚Äôautres 
                  composants. L‚Äô√©cran LCD I2C assure ainsi une lecture claire et en temps r√©el des donn√©es 
                  de vitesse et d‚Äôorientation envoy√©es par la bo√Æte noire.
                </p>
                <div class="image-container">
                  <img src="../images/Test2/Electronique/image6.webp" alt="schema"/>
                </div>
                
              <h4>e. La communication I2C</h4>
                <p>
                  Ce document constitue une pr√©sentation d√©taill√©e et approfondie du protocole I2C 
                  (Inter-Integrated Circuit), qui est un standard de communication s√©rie synchrone tr√®s 
                  r√©pandu dans l‚Äô√©lectronique embarqu√©e. Ce protocole facilite l‚Äô√©change d‚Äôinformations 
                  entre un ou plusieurs ma√Ætres et plusieurs p√©riph√©riques esclaves en utilisant seulement 
                  deux fils, simplifiant ainsi les connexions mat√©rielles tout en assurant une communication 
                  fiable et efficace.
                </p>

                <ul>
                  <li><strong>Principe de fonctionnement</strong></li>
                <p>
                  <a href="https://fr.wikipedia.org/wiki/I2C" target="_blank">Protocole I2C</a> (Inter-Integrated Circuit), d√©velopp√© par Philips (aujourd‚Äôhui NXP) dans les ann√©es 1980, 
                  est un standard mondial pour la communication s√©rie entre circuits int√©gr√©s, 
                  surtout dans les syst√®mes embarqu√©s. Il utilise un bus bidirectionnel √† deux fils : 
                  SDA pour les donn√©es et SCL pour l‚Äôhorloge, permettant √† plusieurs p√©riph√©riques de 
                  partager le m√™me canal tout en g√©rant pr√©cis√©ment l‚Äôacc√®s.
                  Contrairement √† des protocoles comme SPI, I2C minimise le nombre de connexions 
                  n√©cessaires, ce qui simplifie le routage sur circuit imprim√© et r√©duit les co√ªts. 
                  Ce protocole est largement utilis√© dans des domaines vari√©s : 
                  automobile, domotique, informatique, etc.
                </p>
                <p>
                  L'I2C fonctionne selon un mod√®le <a href="https://www.ionos.fr/digitalguide/serveur/know-how/le-principe-master/slave/" target="_blank">ma√Ætre-esclave</a>: un ou plusieurs ma√Ætres contr√¥lent la communication, et les esclaves r√©pondent aux requ√™tes. 
                  Chaque communication commence par une condition <strong>Start</strong>, 
                  suivie de <strong>l‚Äôadresse de l‚Äôesclave</strong> et d‚Äôun bit de direction 
                  (lecture/√©criture). Les donn√©es sont ensuite √©chang√©es octet par octet, 
                  chaque octet √©tant confirm√© par un bit d‚Äôacquittement(ACK). 
                  La communication se termine par une condition <strong>Stop</strong>, qui lib√®re le bus.
                </p>
                <p>
                  Techniquement, I2C utilise des lignes ouvertes (open-drain) : 
                  les dispositifs ne peuvent que tirer les lignes vers le bas, 
                  tandis que des r√©sistances pull-up maintiennent le niveau haut par d√©faut. 
                  Cela √©vite les conflits, notamment en mode multi-ma√Ætres.
                  Enfin, I2C offre une grande flexibilit√© en termes de vitesse, du mode standard 
                  (100 kHz) au mode rapide (jusqu‚Äô√† 3,4 MHz) et au-del√† dans certaines variantes 
                  propri√©taires.
                </p>
                
                <div class="image-container">
                  <img src="../images/Test2/Electronique/image7.webp" alt="schema"/>
                </div>

                <li><strong>Prise de contr√¥le du bus</strong></li>
                <p>
                  La prise de contr√¥le du bus par un ma√Ætre d√©bute par une condition Start (S), 
                  qui est un √©v√©nement distinctif sur le bus. Cette condition correspond √† une transition 
                  sur la ligne SDA de l‚Äô√©tat haut √† l‚Äô√©tat bas, alors que la ligne SCL est maintenue √† 
                  l‚Äô√©tat haut. Cette s√©quence particuli√®re est d√©tect√©e par tous les p√©riph√©riques 
                  connect√©s au bus, qui entrent alors en mode √©coute, pr√™ts √† recevoir des donn√©es.
                </p>
                <p>
                  La condition Start joue un r√¥le fondamental : elle marque l‚Äôexclusivit√© du ma√Ætre sur 
                  le bus, ce qui √©vite les collisions ou l‚Äôinterf√©rence avec d‚Äôautres ma√Ætres √©ventuels. 
                  Elle sert aussi de synchronisation initiale √† la transmission de donn√©es, 
                  en assurant que tous les appareils sont synchronis√©s sur le d√©but de la communication.
                </p>
                <p>
                  Les r√©sistances pull-up sur les lignes SDA et SCL maintiennent ces lignes √† 
                  un √©tat logique haut par d√©faut, garantissant ainsi que le bus est en repos 
                  quand aucune communication n‚Äôa lieu.
                </p>

                <div class="image-container">
                  <img src="../images/Test2/Electronique/image8.webp" alt="schema" class="image-mean"/>
                </div>
                <div class="image-container">
                  <img src="../images/Test2/Electronique/image9.webp" alt="schema" class="image-mean"/>
                </div>

                <li><strong>Transmission d'un octet</strong></li>
                <p>
                  La transmission des donn√©es sur le bus I2C s‚Äôeffectue par octets (8 bits). 
                  Chaque bit est transmis s√©quentiellement, en commen√ßant par le bit le plus significatif 
                  (MSB).
                </p>
                <p>
                  Le protocole impose que chaque bit soit plac√© sur la ligne SDA pendant que la ligne SCL 
                  est √† l‚Äô√©tat bas. Ensuite, la ligne SCL passe √† l‚Äô√©tat haut, moment o√π 
                  le r√©cepteur lit la valeur pr√©sente sur la ligne SDA. 
                  Lorsque la ligne SCL redescend √† l‚Äô√©tat bas, 
                  l‚Äô√©metteur peut placer le bit suivant sur SDA, et ainsi de suite.
                </p>
                <p>
                  Apr√®s l‚Äôenvoi des 8 bits d‚Äôun octet, 
                  la ligne SDA est lib√©r√©e pendant le 9e cycle d‚Äôhorloge. 
                  C‚Äôest alors au r√©cepteur de signaler par un bit d‚Äôacquittement (ACK) s‚Äôil a correctement 
                  re√ßu l‚Äôoctet, en tirant la ligne SDA √† l‚Äô√©tat bas. S‚Äôil ne tire pas SDA √† z√©ro, 
                  un bit de non-acquittement (NACK) est d√©tect√©, ce qui indique que la communication 
                  doit √™tre interrompue ou qu‚Äôune erreur s‚Äôest produite.
                </p>
                <p>
                  Ce m√©canisme d‚Äô<strong>ACK/NACK</strong> est crucial car il assure la fiabilit√© 
                  des transmissions, permettant au ma√Ætre de savoir si l‚Äôesclave est disponible 
                  et pr√™t √† recevoir ou envoyer des donn√©es.
                </p>

                <li><strong>Transmission d'une adresse</strong></li>
                <p>
                  Apr√®s la condition Start, le ma√Ætre envoie un octet d‚Äôadresse pour 
                  identifier l‚Äôesclave avec lequel il souhaite communiquer. 
                  L‚Äôadresse est g√©n√©ralement cod√©e sur 7 bits, suivis d‚Äôun bit R/W indiquant 
                  si la transaction sera une lecture ou une √©criture.
                </p>
                <p>
                  Le protocole pr√©voit aussi une extension 10 bits 
                  pour les r√©seaux comportant un grand nombre de p√©riph√©riques, 
                  mais cette extension est moins fr√©quemment utilis√©e.
                </p>
                <p>
                  Tous les p√©riph√©riques esclaves surveillent le bus 
                  et comparent l‚Äôadresse re√ßue avec leur propre adresse. 
                  Celui qui reconna√Æt son adresse r√©pond alors par un bit ACK en tirant la ligne SDA 
                  √† l‚Äô√©tat bas pendant le 9e bit. Les autres esclaves restent silencieux 
                  jusqu‚Äô√† la prochaine s√©quence.
                </p>
                <p>
                  Cette √©tape est essentielle car elle garantit que seules les communications 
                  destin√©es √† un p√©riph√©rique sp√©cifique sont trait√©es, 
                  √©vitant ainsi toute interf√©rence entre plusieurs p√©riph√©riques sur le m√™me bus.
                </p>
                <div class="image-container">
                  <img src="../images/Test2/Electronique/image10.webp" alt="schema" class="image-mean"/>
                </div>

                <li><strong>√âcriture d'une donn√©e</strong></li>
                <p>
                  Une fois l‚Äôadresse reconnue par l‚Äôesclave, 
                  la phase de transfert des donn√©es peut commencer. 
                  Le ma√Ætre transmet alors les octets de donn√©es √† l‚Äôesclave, 
                  chaque octet √©tant suivi d‚Äôun bit ACK envoy√© par l‚Äôesclave pour confirmer la bonne r√©ception.  
                </p>
                <p>
                  Le protocole permet d‚Äôenvoyer autant d‚Äôoctets que n√©cessaire dans une m√™me communication, ce qui permet des transferts efficaces et continus.
                </p>
                <p>
                  Pour terminer la communication, le ma√Ætre g√©n√®re une condition Stop (P), qui correspond √† une transition de la ligne SDA de l‚Äô√©tat bas √† l‚Äô√©tat haut alors que la ligne SCL est haute. Cette s√©quence indique √† tous les p√©riph√©riques que la transmission est termin√©e et que le bus est lib√©r√© pour une autre communication.
                </p>
                <p>
                  Il existe √©galement une condition Restart, qui est une condition Start g√©n√©r√©e sans condition Stop pr√©alable, permettant de cha√Æner plusieurs op√©rations sur le m√™me bus sans interruption.
                </p>

                <div class="image-container">
                  <img src="../images/Test2/Electronique/image11.webp" alt="schema" class="image-mean"/>
                </div>
                <div class="image-container">
                  <img src="../images/Test2/Electronique/image12.webp" alt="schema" class="image-mean"/>
                </div>

                <li><strong>Arbitration</strong></li>
                <p>
                  Le protocole I2C est con√ßu pour supporter un mode multi-ma√Ætres, o√π plusieurs ma√Ætres peuvent tenter d‚Äôacc√©der au bus simultan√©ment. Pour √©viter les conflits, un m√©canisme d‚Äôarbitrage est mis en place.
                </p>
                <p>
                  Lorsqu‚Äôun ma√Ætre commence √† transmettre, il surveille la ligne SDA et la compare avec ce qu‚Äôil souhaite envoyer. Si un ma√Ætre d√©tecte que la ligne SDA est forc√©e √† l‚Äô√©tat bas par un autre ma√Ætre alors qu‚Äôil tente de la maintenir haute, il comprend qu‚Äôil a perdu l‚Äôarbitrage et abandonne imm√©diatement la transmission, laissant le bus libre au ma√Ætre dominant.
                </p>
                <p>
                  Ce m√©canisme garantit qu‚Äôaucune collision √©lectrique ne se produit sur le bus et que seule une source transmet √† un instant donn√©. C‚Äôest une des forces du protocole I2C, qui permet une coexistence harmonieuse de plusieurs ma√Ætres sur un m√™me bus.
                </p>

                <div class="image-container">
                  <img src="../images/Test2/Electronique/image13.webp" alt="schema" class="image-mean"/>
                </div>

                <li><strong>Clock Stretching</strong></li>
                <p>
                  Le clock stretching est une fonctionnalit√© du protocole I2C qui permet √† un esclave de ralentir temporairement la communication lorsqu‚Äôil n‚Äôest pas pr√™t √† envoyer ou recevoir des donn√©es. Cela se fait en gardant la ligne SCL √† l‚Äô√©tat bas (LOW), emp√™chant ainsi le ma√Ætre de continuer √† envoyer des impulsions d‚Äôhorloge. Une fois que l‚Äôesclave est pr√™t, il lib√®re la ligne SCL, permettant au ma√Ætre de reprendre la transmission. Cette technique est utile, par exemple, lorsque le capteur a besoin de plus de temps pour traiter ou pr√©parer les donn√©es. Le ma√Ætre doit respecter cet √©tirement d‚Äôhorloge pour √©viter des erreurs de communication.
                </p>
                
                <div class="image-container">
                  <img src="../images/Test2/Electronique/image14.webp" alt="schema" class="image-mean"/>
                </div>

                </ul>

            <h4>f. Communication I2C entre MPU6050 et ATmega328P</h4>
                <p>
                  Dans notre projet, le microcontr√¥leur ATmega328P communique avec le capteur MPU6050 √† l‚Äôaide du protocole I2C. Ce protocole permet de transmettre les donn√©es d‚Äôacc√©l√©ration et de rotation via deux fils (SDA et SCL). Le MPU6050 agit comme esclave, et l‚ÄôATmega328P comme ma√Ætre.
                </p>
                <ul>
                  <li><strong>Fonctionnement de la liaison I2C</strong></li>
                <p>
                  La connexion mat√©rielle entre le MPU6050 et l‚ÄôATmega328P s‚Äôeffectue via le protocole I2C (Inter-Integrated Circuit), qui utilise deux lignes de communication :
                </p>
                <ul>
                  <li>SDA (Serial Data Line) : ligne bidirectionnelle pour l‚Äô√©change des donn√©es, connect√©e √† la broche PC4 de l‚ÄôATmega328P.</li>
                  <li>SCL (Serial Clock Line) : ligne d‚Äôhorloge g√©n√©r√©e par le ma√Ætre, connect√©e √† la broche PC5 de l‚ÄôATmega328P.</li>
                </ul>
                <p>
                  Sur le bus I2C, le dispositif qui initie la communication est appel√© ma√Ætre, tandis que celui qui r√©pond s‚Äôappelle esclave. Dans notre cas :
                  L‚ÄôATmega328P joue le r√¥le de ma√Ætre, c‚Äôest lui qui contr√¥le le bus, g√©n√®re l‚Äôhorloge, et initie les √©changes.
                  Le MPU6050 est l‚Äôesclave, il attend que le ma√Ætre lui demande des donn√©es sp√©cifiques.
                  Le ma√Ætre d√©marre la communication en envoyant une adresse unique correspondant √† l‚Äôesclave (ici l‚Äôadresse I2C du MPU6050, g√©n√©ralement 0x68), suivie d‚Äôune commande indiquant quel registre ou donn√©e il souhaite lire.
                  </p>
                <div class="image-container">
                  <img src="../images/Test2/Electronique/image15.webp" alt="schema" class="image-mean"/>
                </div>


                  <li><strong>Envoi des commandes et r√©ception des donn√©es</strong></li>
                <p>
                  La communication suit ce processus 
                </p>
                <ul>
                  <li>Le ma√Ætre (ATmega328P) commence par envoyer une commande au MPU6050, qui consiste √† sp√©cifier l‚Äôadresse du registre interne dont il souhaite lire la valeur. Par exemple, pour lire l‚Äôacc√©l√©ration sur l‚Äôaxe X, il envoie l‚Äôadresse du registre ACCEL_XOUT_H.</li>
                  <li>Cette commande est envoy√©e via le bus I2C sous forme d‚Äôune trame contenant l‚Äôadresse de l‚Äôesclave, suivie de l‚Äôadresse du registre cibl√©.</li>
                  <li>Une fois la commande re√ßue, le MPU6050 pr√©pare la donn√©e correspondante et la transmet d√®s que le ma√Ætre la demande.</li>
                  <li>Le ma√Ætre r√©cup√®re alors la ou les valeurs envoy√©es par le capteur, g√©n√©ralement sur plusieurs octets, qu‚Äôil traite ensuite pour en extraire l‚Äôinformation de mouvement (acc√©l√©ration, rotation, temp√©rature).</li>
                </ul>
                
              </ul>

          <h3 id="5-test2">5. Etapes de validation avant PCB</h3>
              <h4>a. √âtape 1 : Communication I2C entre deux Arduino (Test de base)</h4>
                <p>
                  Afin de valider le fonctionnement de la communication I2C entre deux microcontr√¥leurs en utilisant un exemple simple : un bouton poussoir et une LED.
                </p>
                <p>
                  Composants utilis√©s :
                </p>
                <ul>
                  <li>2 cartes Arduino UNO</li>
                  <li>1 bouton poussoir (sur le ma√Ætre)</li>
                  <li>1 LED (sur l‚Äôesclave)</li>
                  <li>C√¢blage SDA/SCL entre les deux cartes</li>
                </ul>

                <p>
                  Fonctionnement  :
                </p>
                <ul>
                  <li>L‚ÄôArduino ma√Ætre lit l‚Äô√©tat d‚Äôun bouton poussoir connect√© en entr√©e.</li>
                  <li>Cet √©tat (appuy√© ou rel√¢ch√©) est transmis √† l‚ÄôArduino esclave via le protocole I2C.</li>
                  <li>L‚Äôesclave re√ßoit cette donn√©e et contr√¥le une LED : elle s‚Äôallume si le bouton est appuy√©, s‚Äô√©teint sinon.</li>
                </ul>

                <p>
                  But de l'√©tape : 
                </p>
                <ul>
                  <li>Apprendre √† configurer le bus I2C (ma√Ætre/esclave).</li>
                  <li>V√©rifier la synchronisation et la fiabilit√© de la communication.</li>
                  <li>Observer une r√©ponse simple √† un signal I2C.</li>
                </ul>

                <div class="image-container">
                  <img src="../images/Test2/Electronique/image16.webp" alt="schema"/>
                </div>

                <video controls width=30%>
                  <source src="../videos/Test2/Electronique/video2.mp4" type="video/mp4">
                  Votre navigateur ne supporte pas la vid√©o HTML5.
                </video>
            
            <h4>b. √âtape 2 : Remplacement par des modules r√©els (MPU6050 et LCD)</h4>
                <p>
                  Pour simuler une application plus r√©aliste en utilisant des capteurs r√©els(MPU6050) et un afficheur(lCD), tout en gardant la communication I2C entre deux cartes.
                </p>
                <p>
                  Composants utilis√©s :
                </p>
                <ul>
                  <li>MPU6050 (capteur acc√©l√©rom√®tre/gyroscope) sur le ma√Ætre</li>
                  <li>√âcran LCD (type I2C 16x2) sur l‚Äôesclave</li>
                  <li>Deux cartes Arduino</li>
                </ul>

                <p>
                  Fonctionnement  :
                </p>
                <ul>
                  <li>Le capteur MPU6050 collecte les donn√©es d‚Äôacc√©l√©ration et de rotation.</li>
                  <li>Ces donn√©es sont lues par l‚ÄôArduino ma√Ætre via I2C.</li>
                  <li>Le ma√Ætre envoie ensuite les valeurs trait√©es √† l‚Äôesclave.</li>
                  <li>L‚ÄôArduino esclave re√ßoit les donn√©es et les affiche sur le LCD.</li>
                </ul>

                <p>
                  But de l'√©tape : 
                </p>
                <ul>
                  <li>Remplacer des composants de test par des modules intelligents.</li>
                  <li>Manipuler un capteur complexe avec acquisition de donn√©es.</li>
                  <li>G√©rer l'affichage distant d'informations, toujours via I2C.</li>
                  <li>Approfondir le protocole I2C dans un cas concret (multi-esclaves potentiels, synchronisation).</li>
                </ul>

                <div class="image-container">
                  <img src="../images/Test2/Electronique/image17.webp" alt="schema"/>
                </div>

                <video controls width=60%>
                  <source src="../videos/Test2/Electronique/video3.mp4" type="video/mp4">
                  Votre navigateur ne supporte pas la vid√©o HTML5.
                </video>

            <h4>c. √âtape 3 : Int√©gration avec ATmega328P (pr√©paration au PCB)</h4>
                <p>
                Afin de remplacer la carte Arduino par le <strong>microcontr√¥leur brut</strong> (ATmega328P), et de simuler les conditions r√©elles d‚Äôun circuit imprim√©.
                </p>
                <p>
                  Composants utilis√©s :
                </p>
                <ul>
                  <li>2√ó ATmega328P</li>
                  <li>2√ó Quartz</li>
                  <li>4√ó Condensateurs 22 pF</li>
                  <li>1√ó MPU6050</li>
                  <li>1√ó √âcran LCD 16x2 avec interface I2C</li>
                  <li>2√ó Boutons poussoirs</li>
                  <li>2√ó R√©sistances 10 kŒ©</li>
                  <li>Fils de connexion (Dupont)</li>
                  <li>Breadboard</li>
                </ul>

                <p>
                  Fonctionnement  :
                </p>
                <ul>
                  <li>L‚ÄôATmega328P est programm√© avec le m√™me code que celui utilis√© sur une carte Arduino, √† l‚Äôaide d‚Äôun programmateur externe (comme USBasp ou Arduino as ISP).</li>
                  <li>Les deux ATmega328P communiquent via le protocole I2C :</li>
                  <ul>
                    <li>L‚Äôun joue le r√¥le de ma√Ætre (elle collecte les donn√©es du MPU6050).</li>
                    <li>L‚Äôautre joue le r√¥le d‚Äôesclave (elle affiche les donn√©es sur un √©cran LCD I2C).</li>
                  </ul>
                  <li>Les microcontr√¥leurs sont utilis√©s en mode "standalone" (hors carte de d√©veloppement).</li>
                  <li>Connect√©s sur breadboard avec :</li>
                  <ul>
                    <li>Un quartz et deux condensateurs 22 pF pour chaque ATMEGA328P pour g√©n√©rer l‚Äôhorloge.</li>
                    <li>Une alimentation 5V stable.</li>
                    <li>Un bouton poussoir reli√© √† la broche RESET de chaque ATmega.</li>
                    <li>Une r√©sistance de 10 kŒ© connect√©e entre la broche RESET et VCC, pour garantir un red√©marrage stable.</li>
                  </ul>
                </ul>
                
                <p>
                  But de l'√©tape : 
                </p>
                <ul>
                  <li>S‚Äôassurer que le microcontr√¥leur fonctionne correctement en mode autonome.</li>
                  <li>Tester la communication I2C dans les conditions mat√©rielles r√©elles du futur PCB.</li>
                  <li>Pr√©parer l‚Äôint√©gration finale des composants sur un PCB personnalis√©.</li>
                </ul>

                <div class="image-container">
                  <img src="../images/Test2/Electronique/image16.webp" alt="schema" class="image-small"/>              
                </div>

                <video controls width=30%>
                  <source src="../videos/Test2/Electronique/video4.mp4" type="video/mp4">
                  Votre navigateur ne supporte pas la vid√©o HTML5.
                </video>


              <div class="code-container">
                <p>Code_maitre.ino </p>
                <div class="btn-bar">
                  <button onclick="copierCode('Code_maitre-ino', this)">üìã</button>
                  <button onclick="telechargerCode('Code_maitre-ino', 'Code_maitre.ino', 'text/ino', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="Code_maitre-ino">
#include &lt;Wire.h&gt;        
#include &lt;MPU6050.h&gt;  

MPU6050 mpu;

float ax, ay, az;
const float threshold = 0.2;
String direction = "";

void setup() {
  Serial.begin(9600);
  Wire.begin();      // Ma√Ætre
  mpu.initialize();

  if (!mpu.testConnection()) {
    Serial.println("Erreur MPU6050");
    while (1);
  }

  Serial.println("MPU6050 OK");
}

void loop() {
  int16_t rawAx, rawAy, rawAz;
  mpu.getAcceleration(&rawAx, &rawAy, &rawAz);

  ax = rawAx / 16384.0;
  ay = rawAy / 16384.0;
  az = rawAz / 16384.0;

  // D√©tection de direction
  if (ax > threshold) direction = "Gauche";
  else if (ax < -threshold) direction = "Droite";
  else if (ay > threshold) direction = "Arriere";
  else if (ay < -threshold) direction = "Avant";
  else if (az > threshold) direction = "Haut";
  else if (az < -threshold) direction = "Bas";
  else direction = "Stable";

  // Envoi vers esclave
  Wire.beginTransmission(8);         // adresse esclave
  Wire.write(direction.c_str());     // envoyer la direction comme texte
  Wire.endTransmission();

  Serial.print("Direction envoy√©e : ");
  Serial.println(direction);

  delay(300);
}                      
                  </code></pre>
                </div>

              <div class="code-container">
                <p>Code_esclave.ino </p>
                <div class="btn-bar">
                  <button onclick="copierCode('Code_esclave-ino', this)">üìã</button>
                  <button onclick="telechargerCode('Code_esclave-ino', 'Code_esclave.ino', 'text/ino', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="Code_esclave-ino">
#include &lt;Wire.h&gt;               // Biblioth√®que pour communication I2C
#include &lt;LiquidCrystal_I2C.h&gt;  // Biblioth√®que pour √©cran LCD I2C
#include &lt;MPU6050.h&gt;  

LiquidCrystal_I2C lcd(0x27, 16, 2);  // LCD I2C

String receivedDirection = "";

void setup() {
  Wire.begin(8);  // Adresse de l'esclave
  Wire.onReceive(receiveData);

  lcd.init();
  lcd.backlight();
  lcd.setCursor(0, 0);
  lcd.print("Pret a recevoir");
}

void loop() {
  // Affiche la derni√®re direction re√ßue
  lcd.setCursor(0, 0);
  lcd.print("Dir:            "); // Nettoyer la ligne
  lcd.setCursor(5, 0);
  lcd.print(receivedDirection);
  
  delay(200);
}

void receiveData(int bytes) {
  receivedDirection = ""; // r√©initialiser

  while (Wire.available()) {
    char c = Wire.read();
    receivedDirection += c;
  }

  Serial.print("Recu : ");
  Serial.println(receivedDirection);
}         
                  </code></pre>
                </div>
                
            <h4>Pourquoi cette D√©marche ?</h4>
            <p>
              La r√©alisation d‚Äôun PCB n√©cessite des choix pr√©cis de composants et un bon fonctionnement garanti en amont. Cette d√©marche par √©tapes nous a permis de :
            </p>
            <ul>
              <li>Identifier les erreurs √©ventuelles (bruit sur la ligne I2C, mauvais c√¢blage, alimentation instable‚Ä¶).</li>
              <li>Tester progressivement les modules dans un environnement de d√©veloppement.</li>
              <li>R√©duire le risque d‚Äôerreur lors de la conception du PCB.</li>
              <li>Avoir une base fonctionnelle avant le passage √† la fabrication.</li>
            </ul>
          

          <h3 id="6-test2">6. R√©alisation du PCB</h3>
            <h4>a. PCB de la boite noire</h4>
            <div class="image-container">
              <img src="../images/Test2/Electronique/image18.webp" alt="pcb" class="image-mean"/>
              <p class = "txt_center">
                Conception du sch√©ma int√©grant le microcontr√¥leur ATmega328P, le capteur MPU-6050 et les connecteurs.
              </p>
            </div>
            
            <div class="image-container">
              <img src="../images/Test2/Electronique/image19.webp" alt="pcb" class="image-mean"/>
              <p class = "txt_center">
                Attribution des empreintes physiques correspondant aux composants.
              </p>
            </div>
        
            <div class="image-container">
              <img src="../images/Test2/Electronique/image20.webp" alt="pcb" class="image-mean"/>
              <p class = "txt_center">
                Verificaton des erreurs (DRC)
              </p>
            </div>
            
            <div class="image-container">
              <img src="../images/Test2/Electronique/image21.webp" alt="pcb" class="image-mean"/>
              <p class = "txt_center">
                Ajustement de la disposition pour optimiser l‚Äôespace et faciliter le routage.
              </p>
            </div>

            <div class="image-container">
              <img src="../images/Test2/Electronique/image22.webp" alt="pcb" class="image-mean"/>
              <p class = "txt_center">
                Routage des pistes
              </p>
            </div>
            

            <div class="image-container">
              <img src="../images/Test2/Electronique/image23.webp" alt="pcb" class="image-mean"/>
              <p class = "txt_center">
                D√©finition des contours du PCB (Edge Cuts)
              </p>
            </div>

            <div class="image-container">
              <p class = "txt_center">
                Visualisation 3D du PCB
              </p>
              <img src="../images/Test2/Electronique/image24.webp" alt="pcb" class="image-mean"/>
            </div>
            <video controls width=60%>
              <source src="../videos/Test2/Electronique/video5.mp4" type="video/mp4">
              Votre navigateur ne supporte pas la vid√©o HTML5.                   
            </video>

            <p class="txt_center">
              <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test2/Electronique/boite_noire.zip" target="_blank" class="download-link">t√©l√©charger le pcb de la boite noire</a>
            </p>

          <h4>b. PCB de la station de contr√¥le</h4>
          
              <div class="image-container">
                <img src="../images/Test2/Electronique/image25.webp" alt="pcb" class="image-mean"/>
                <p class = "txt_center">
                  Conception du sch√©ma int√©grant le microcontr√¥leur ATmega328P, le capteur MPU-6050 et les connecteurs.
                </p>
              </div>
            
              <div class="image-container">
                <img src="../images/Test2/Electronique/image26.webp" alt="pcb" class="image-mean"/>
                <p class = "txt_center">
                  Anotation
                </p>
              </div>
            
              <div class="image-container">
              <img src="../images/Test2/Electronique/image27.webp" alt="pcb" class="image-mean"/>
                <p class = "txt_center">
                  Attribution des empreintes physiques correspondant aux composants.
                </p>
              </div>
            
              <div class="image-container">
                <img src="../images/Test2/Electronique/image28.webp" alt="pcb" class="image-mean"/>
                <p class = "txt_center">
                Verificaton des erreurs (DRC)
              </p>
              </div>

              <div class="image-container">
                <img src="../images/Test2/Electronique/image29.webp" alt="pcb" class="image-mean"/>
                <p class = "txt_center">
                  Organisation du PCB
                </p>
              </div>
              
              <div class="image-container">
                <img src="../images/Test2/Electronique/image30.webp" alt="pcb" class="image-mean"/>
                <p class = "txt_center">
                  D√©finition des contours du PCB (Edge Cuts)
                </p>
              </div>
                
              <div class="image-container">
                <img src="../images/Test2/Electronique/image31.webp" alt="pcb" class="image-mean"/>
                <p class = "txt_center">
                  Plan de masse GND  
                </p>
              </div>
            
              <div class="image-container">
                <img src="../images/Test2/Electronique/image32.webp" alt="pcb" class="image-mean"/>
                <p class = "txt_center">
                  Routage
                </p>
              </div>

              <div class="image-container">
                <p class = "txt_center">
                  Visualisation 3D du PCB
                </p>
                <img src="../images/Test2/Electronique/image33.webp" alt="pcb" class="image-mean"/>
              </div>
              <video controls width=60%>
                <source src="../videos/Test2/Electronique/video6.mp4" type="video/mp4">
                Votre navigateur ne supporte pas la vid√©o HTML5.                   
              </video>
            <p class="txt_center">
              <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test2/Electronique/controle%20station.zip" target="_blank" class="download-link">t√©l√©chager le pcb de la station de contr√¥le</a>
            </p>


        <h3 id="7-test2">7. Prototype</h3>
          <div class="image-container">
            <img src="../images/Test2/Electronique/prototype0.webp" alt="pcb" class="image-small" />
          </div>

          <video controls width=30%>
            <source src="../videos/Test2/Electronique/video7.mp4" type="video/mp4">
            Votre navigateur ne supporte pas la vid√©o HTML5.                   
          </video>

          <div class="image-container">
            <img src="../images/Test2/Electronique/prototype1.webp" alt="pcb" class="image-small" />
            <img src="../images/Test2/Electronique/prototype2.webp" alt="pcb" class="image-small" />
          </div>
        </div>
      </section>
    </main>
  </div>

  <footer>
    Copyright ¬© 2025 Team B2MS CleanTech. All rights reserved.
  </footer>

  <script src="../scripts/script_commun.js"></script>
  <script src="../scripts/script_code.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</body>
</html>
