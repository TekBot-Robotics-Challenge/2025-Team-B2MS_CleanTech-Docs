<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css"
    />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles/style-commun.css" />
  <link rel="stylesheet" href="../styles/style-code.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/srcery.min.css">
  <link rel="icon" type="image/x-icon" href="../logo/favicon.ico">
  <title>R√©silience Urbaine - B2MS CleanTech</title>
</head>
<body>
  <header class="header">
    <div class="section__container header__container_domaine">
      <h2>R√©silience Urbaine</h2>
    </div>
  </header>

  <div class="layout-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="sidebar-toggle" id="sidebarToggle">
        <i class="fas fa-bars"></i>
      </div>

      <nav class="main-nav">
        <a href=".././" class="nav-link"><i class="fas fa-home"></i> Accueil</a>
        <a href="./it" class="nav-link"><i class="fas fa-desktop"></i> IT</a>
        <a href="./electronique" class="nav-link"><i class="fas fa-microchip"></i> √âlectronique</a>
        <a href="./mecanique" class="nav-link"><i class="fas fa-cogs"></i> M√©canique</a>
        <a href="./convoyeur" class="nav-link"></i><i class="fas fa-forward"></i> Convoyeur</a>

        <div class="nav-section">
          <a href="./trc25" style="text-decoration: none;"><button class="tab-button active"><i class="fas fa-robot"></i> TRC25</button> </a>       
          <div class="sub-links">
            <a class="subtab-button active" href="./trc25-convoyeur">Convoyeur 2.0</a>
            <nav class="project-subnav active" id="subnav-convoyeur">
              <a href="#1-conv">1. Vers convoyeur 2.0</a>
              <a href="#2-conv">2. Am√©liorations m√©caniques</a>
              <a href="#3-conv">3. Am√©liorations √©lectroniques</a>
              <a href="#4-conv">4. Programmation</a>
              <a href="#5-conv">5. Tests fonctionnels</a>
            </nav>
            <a class="subtab-button" href="./trc25-dofbot">Prise en main du Dofbot</a>
            <a class="subtab-button" href="./trc25-communication">Communication Dofbot - Convoyeur</a>
            <a class="subtab-button" href="./trc25-yolo">Mod√®le de d√©tection YOLO</a>
            <a class="subtab-button" href="./trc25-dofbot_ia">D√©tection et tri - Dofbot</a>
            <a class="subtab-button" href="./trc25-ros">ROS</a>
            <a class="subtab-button" href="./trc25-meca">Syst√®me de ramassage</a>
          </div>
        </div>

      </nav>
    </div>

    <!-- Contenu principal -->
    <main class="main-content">
      <section class="tab-content active">
        <div class="subtab-content active">
          <h2 id="convoyeur" class="projet-titre">Convoyeur 2.0</h2>
            
          <h3 id="1-vers_conv2">1. Vers convoyeur 2.0</h3>
            <p>
              Lors de la phase de pr√©s√©lection de la TRC 2025, une premi√®re version du convoyeur destin√© au tri et au transport des d√©chets a √©t√© con√ßue et test√©e. 
              Bien que fonctionnelle, cette version initiale pr√©sentait plusieurs limites, tant sur le plan m√©canique qu‚Äô√©lectronique.
              <br>
              La conception du Convoyeur 2.0 vise √† corriger ces limites en se concentrant sur deux axes principaux :
                <ul>
                  <li><strong>Am√©liorations m√©caniques:</strong> remplacement du bois par des pi√®ces imprim√©es en 3D, structure d√©montable en quatre parties, syst√®me d'ajustement de tension du tapis optimis√© et supports de capteurs repens√©s.</li>
                  <li><strong>Am√©liorations √©lectroniques:</strong> meilleure int√©gration des capteurs, c√¢blage optimis√©, support moteur stabilis√© et fiabilisation g√©n√©rale du fonctionnement.</li>
                </ul>
            </p>
            <p>
              L‚Äôobjectif du Convoyeur 2.0 est d‚Äôoffrir une structure plus solide, modulable, 
              facilement r√©parable et mieux adapt√©e √† l‚Äôint√©gration dans le syst√®me de tri intelligent pour la TRC 2025.
            </p>

          <h3 id="2-conv">2. Am√©liorations m√©caniques</h3>
            <p>
              Le Convoyeur 2.0 int√®gre plusieurs am√©liorations m√©caniques visant √† rendre le syst√®me <strong>plus robuste</strong>, 
              <strong>modulable</strong> et <strong>facile √† entretenir</strong>, tout <strong>en conservant les √©l√©ments fonctionnels essentiels</strong> de la version pr√©c√©dente (roulements, tambours, moteur, ...).
            </p>

            <h4>a. Structure d√©montable</h4>
              <p>
                La structure initiale en bois a √©t√© remplac√©e par des pi√®ces imprim√©es en 3D. 
                Le convoyeur est d√©sormais enti√®rement d√©montable, d√©coup√© en quatre parties principales, ce qui facilite le transport, l‚Äôassemblage et la maintenance.
              </p>
              <div class="image-container">
                <img src="../images/TRC25/Convoyeur/conv1.webp" alt="bord" class="image-small"/>
                <img src="../images/TRC25/Convoyeur/conv2.webp" alt="bord" class="image-small"/>
                <img src="../images/TRC25/Convoyeur/conv3.webp" alt="bord" class="image-small"/>
                <img src="../images/TRC25/Convoyeur/conv4.webp" alt="bord" class="image-small"/>
                <img src="../images/TRC25/Convoyeur/conv5.webp" alt="bord" class="image-small"/>
                <img src="../images/TRC25/Convoyeur/conv6.webp" alt="bord" class="image-small"/>
              </div>

              <h4>b. Syst√®me d‚Äôajustement de la tension du tapis</h4>
                <p>
                  Un nouveau m√©canisme permet de r√©gler pr√©cis√©ment la tension du tapis. 
                  Ce syst√®me est compos√© de deux <strong>vis filet√©es</strong> et de <strong>trois √©crous</strong> mont√©s autour d‚Äôun support central accueillant le tambour arri√®re. 
                  En vissant ou d√©vissant, les √©crous se d√©placent axialement, entra√Ænant le support et ajustant la tension du tapis pour √©viter tout glissement.
                </p>
                <div class="image-container">
                  <img src="../images/TRC25/Convoyeur/conv9.webp" alt="vis" class="image-small"/>
                  <img src="../images/TRC25/Convoyeur/conv10.webp" alt="ecrou" class="image-small"/>
                  <br>
                  <img src="../images/TRC25/Convoyeur/conv11.webp" alt="support du tambour" class="image-small"/>
                  <img src="../images/TRC25/Convoyeur/conv12.webp" alt="syst√®me d‚Äôajustement de la tension" class="image-small"/>
                </div>

              <h4>c. Supports</h4>
                <ul>
                  <li>
                    <strong>Support du capteur de fin de convoyage:</strong> 
                    int√©gr√© et con√ßu pour maintenir le capteur en position stable et fiable √† la sortie du convoyeur.
                    <div class="image-container">
                      <img src="../images/TRC25/Convoyeur/conv13.webp" alt="support du capteur infrarouge" class="image-small"/>
                    </div>
                  </li>
                  <li>
                    <strong>Support du capteur ultrason:</strong> 
                    con√ßu pour maintenir le capteur en position stable et pr√©cise afin de d√©tecter la pr√©sence des d√©chets sur le convoyeur.
                    <div class="image-container">
                      <img src="../images/TRC25/Convoyeur/conv14.webp" alt="support du capteur ultrason" class="image-small"/>
                    </div>
                  </li>
                  
                  <li>
                    <strong>Supports de l'alimentation:</strong> 
                    pour fixer et s√©curiser le syst√®me d‚Äôalimentation.
                    <div class="image-container">
                      <img src="../images/TRC25/Convoyeur/conv16.webp" alt="support de l'alimentation" class="image-small"/>
                    </div>
                  </li>
                  <li>
                    <strong>Supports du pupitre et des circuits:</strong> 
                    pour les boutons de contr√¥le et la LED de signalisation, ainsi que les circuits.
                    <div class="image-container">
                      <img src="../images/TRC25/Convoyeur/conv17.webp" alt="support du pupitre de commande" class="image-small"/>
                    </div>
                  </li>
                  <li>
                    <strong>Supports du tapis:</strong> 
                    pour soutenir et maintenir le tapis en place.
                    <div class="image-container">
                      <img src="../images/TRC25/Convoyeur/conv15.webp" alt="support du tapis" class="image-small"/>
                    </div>
                  </li>
                </ul>

              <h4>d. Autres pi√®ces supplementaires</h4>
                <ul>
                  <li>
                    <strong>Pi√®ce de fixation du moteur:</strong> 
                    con√ßue pour assurer le maintien, l‚Äôalignement correct et la stabilit√© du moteur.
                    <div class="image-container">
                      <img src="../images/TRC25/Convoyeur/conv27.webp" alt="support du capteur infrarouge" class="image-small"/>
                    </div>
                  </li>
                  <li>
                    <strong>Pi√®ce de fin de convoyage:</strong> 
                    plac√©e √† l‚Äôextr√©mit√© du convoyeur afin de guider et recentrer les d√©chets vers le milieu du tapis avant la phase de d√©tection et de tri.
                    <div class="image-container">
                      <img src="../images/TRC25/Convoyeur/conv28.webp" alt="support du capteur ultrason" class="image-small"/>
                    </div>
                  </li>
                </ul>
                
              <h4>e. Assemblage sous SolidWorks</h4>
                <p>
                  Toutes les pi√®ces ont √©t√© mod√©lis√©es sur SolidWorks, puis assembl√©es sous SolidWorks.
                </p>
                <div class="image-container">
                  <img src="../images/TRC25/Convoyeur/conv18.webp" alt="convoyeur sous solidworks" class="image-small"/>
                  <img src="../images/TRC25/Convoyeur/conv19.webp" alt="convoyeur sous solidworks" class="image-small"/>
                </div>

                <p class="txt_center">
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/TRC25/b2ms_Convoyeur/b2ms_Conv_Meca.zip" target="_blank" class="download-link">
                    T√©l√©charger b2ms_Conv_Meca.zip
                  </a>
                </p>

              <h4>f. Impression et assemblage</h4>
                <p>
                  Apr√®s mod√©lisation sur SolidWorks et validation des pi√®ces par l‚Äô√©quipe m√©canique, 
                  toutes les pi√®ces ont √©t√© imprim√©es en 3D puis assembl√©es pour constituer le convoyeur.
                </p>
                <div class="image-container">
                  <img src="../images/TRC25/Convoyeur/conv20.webp" alt="pi√®ces imprim√©es" class="image-small"/>
                  <br>
                  <img src="../images/TRC25/Convoyeur/conv21.webp" alt="assemblage" class="image-small"/>
                  <img src="../images/TRC25/Convoyeur/conv22.webp" alt="assemblage" class="image-small"/>
                </div>

          <h3 id="3-conv">3. Am√©liorations √©lectroniques</h3>
            <p>
              Le Convoyeur 2.0 int√®gre plusieurs am√©liorations √©lectroniques pour renforcer la fiabilit√©, la flexibilit√© et la connectivit√© du syst√®me.
            </p>

            <h4>a. Alimentation</h4>
              <p>
                Le Convoyeur 2.0 conserve l‚Äôalimentation par batterie de la version pr√©c√©dente, garantissant ainsi la portabilit√© du syst√®me 
                et son fonctionnement m√™me en l‚Äôabsence d‚Äôune source secteur. 
                Cette configuration permet de d√©placer facilement le convoyeur et de l‚Äôutiliser dans diff√©rents environnements sans d√©pendre d‚Äôune prise √©lectrique.
                <br>
                Pour accro√Ætre la flexibilit√© et permettre un fonctionnement prolong√©, un syst√®me d‚Äôalimentation par prise secteur a √©t√© ajout√©. 
                Cette option fournit une source d‚Äô√©nergie alternative et continue, r√©duisant la d√©pendance aux batteries 
                et assurant une disponibilit√© permanente lors de tests prolong√©s ou d‚Äôune utilisation intensive.
              </p>
              <div class="image-container">
                <img src="../images/TRC25/Convoyeur/conv23.webp" alt="alimentation" class="image-small"/>
              </div>

              <h4>b. Communication et connectivit√©</h4>
                <ul>
                  <li>
                    <strong>Communication I2C:</strong>
                     une interface I2C a √©t√© ajout√©e pour permettre une liaison rapide et fiable entre le <strong>convoyeur</strong> et le <strong>DOFBOT</strong>. 
                     Cette communication facilite l‚Äô√©change de donn√©es et le contr√¥le des diff√©rents modules du syst√®me, tout en simplifiant le c√¢blage et l‚Äôint√©gration.
                  </li>
                  <li>
                    <strong>Module Wi-Fi ESP01:</strong>
                    le module Wi-Fi ESP01 a √©t√© int√©gr√© afin de transmettre les donn√©es du convoyeur en temps r√©el. 
                    Il permet la supervision √† distance du fonctionnement, le suivi des capteurs et le contr√¥le du convoyeur. 
                    Cette connectivit√© am√©liore la flexibilit√© du syst√®me et facilite le diagnostic et la maintenance.
                  </li>
                </ul>
                <p>
                  Pour assurer la compatibilit√© des deux communications, un <strong>r√©gulateur de tension 5V √† 3,3V</strong> a √©t√© utilis√© afin d'alimenter correctement les modules n√©cessitant une tension plus faible.
                  Un <strong>convertisseur de niveau logique</strong> a √©galement √©t√© int√©gr√© pour adapter les signaux entre le microcontr√¥leur et les p√©riph√©riques, garantissant ainsi une communication fiable et s√©curis√©e pour l'I¬≤C et le module Wi-Fi ESP01.
                </p>

                <div class="image-container">
                  <img src="../images/TRC25/Convoyeur/convertisseur_niveaux_logiques.webp" alt="Convertisseur de niveau logique bidirectionnel 3.3V-5V" class="image-small"/>
                  <p class="txt_center">
                    <a href="https://www.tme.eu/Document/3d637fa1410688f9bd1aa00171908361/POLOLU-2595.pdf" target="_blank">Convertisseur de niveau logique bidirectionnel 3.3V-5V</a>
                  </p>
                </div>

                <div class="image-container">
                  <img src="../images/TRC25/Convoyeur/circuit2.webp" alt="circuit de communication" class="image-mean"/>
                  <img src="../images/TRC25/Convoyeur/conv24.webp" alt="circuit communication" class="image-small"/>
                </div>

              <h4>c. Commandes</h4>
                <ul>
                  <li>
                    <strong>Marche/Arr√™t:</strong>
                    Les deux boutons poussoirs ont √©t√© remplac√©s par un interrupteur √† bascule, offrant un contr√¥le plus pratique et moins encombrant.
                  </li>
                  <li>
                    <strong>Reset du convoyeur</strong>
                    un bouton de r√©initialisation a √©t√© ajout√© pour permettre de red√©marrer rapidement le microcontr√¥leur en cas de besoin, facilitant la maintenance et le d√©bogage.
                  </li>
                </ul>
                <div class="image-container">
                  <img src="../images/TRC25/Convoyeur/conv25.webp" alt="commandes et interfaces" class="image-small"/>
                </div>

              <h4>d. C√¢blage</h4>
                <p>
                  Le c√¢blage a √©t√© r√©organis√© afin de faciliter la maintenance et de r√©duire les risques de court-circuit.
                  Toutes les connexions sont s√©curis√©es et facilement accessibles, garantissant ainsi un fonctionnement stable et fiable du convoyeur.
                </p>
                <div class="image-container">
                  <img src="../images/TRC25/Convoyeur/conv26.webp" alt="cablage du convoyeur" class="image-small"/>
                </div>

          <h3 id="4-conv">4. Programmation</h3>
            <ul>Le microcontr√¥leur du convoyeur a √©t√© programm√© pour :
              <li>
                Lire en temps r√©el les capteurs(ultrason et infrarouge).
              </li>
              <li>
                Contr√¥ler le moteur.
              </li>
              <li>
                Assurer la communication avec le DOFBOT.
              </li>
              <li>
                R√©agir aux commandes utilisateur(interrupteur √† bascule, bouton reset) et s√©curiser le fonctionnement du syst√®me.
              </li>
            </ul>
            <p>
              Le code est structur√© de mani√®re modulaire, facilitant la maintenance et les futures am√©liorations.
            </p>

            <details class="code-container">
              <summary>code_convoyeur.ino</summary>
              <div class="btn-bar">
                <button onclick="copierCode('code_convoyeur-ino', this)">üìã</button>
                <button onclick="telechargerCode('code_convoyeur-ino', 'code_convoyeur.ino', 'text/ino', this)">ü°á</button>
              </div>
              <pre><code class="hljs" id="code_convoyeur-ino">
#include &lt;SoftwareSerial.h&gt;

#define pinStart 2

// Contr√¥le moteur
#define pinMotor 3

// D√©finir les broches du capteur de couleur
#define LED_R 9
#define LED_G 10
#define LED_B 11

// capteur infrarouge
#define infraredSensor 8

// capteur Ultrason
#define trigPin 6
#define echoPin 5

// RX, TX
SoftwareSerial espSerial(4, 7);

unsigned long distance = 0, lastInterrupt = 0, lastSend = 0;
bool finTapis = true;
volatile bool is_on = false;

const int vitesse = 250;



void setup()
{
    // Moteur
    pinMode(pinMotor, OUTPUT);
    analogWrite(pinMotor, 0); // arr√™t initial

    // LED
    pinMode(LED_R, OUTPUT);
    pinMode(LED_G, OUTPUT);
    pinMode(LED_B, OUTPUT);
    setColor(0, 0, 0); // blanc

    // Ultrason
    pinMode(trigPin, OUTPUT);
    pinMode(echoPin, INPUT);

    // Infrarouge
    pinMode(infraredSensor, INPUT);

    // interrupteur √† bascule
    pinMode(pinStart, INPUT);
    attachInterrupt(digitalPinToInterrupt(pinStart), interrupt_routine, CHANGE);

    Serial.begin(9600);
    espSerial.begin(9600); 
    delay(1000);
    is_on = digitalRead(pinStart);
}


void loop()
{
  if (!is_on)
  {
    // led en rouge pour indiquer que le syst√®me est en stop
    setColor(255, 0, 0);
    analogWrite(pinMotor, 0);
    while (!is_on)
    {      
      delay(100);
    }
  }
  else
  {
    distance = getDistance();
    int infraredValue = digitalRead(infraredSensor);

    if (infraredValue)
    {
      analogWrite(pinMotor, 0);
      finTapis = true;
      setColor(255, 165, 0);
      send_info();
    }

    else if (distance < 50 || !finTapis)
    {
      setColor(0, 255, 0);
      if(distance < 15){
        delay(500);
        finTapis = false;
        lastSend = 0;
        analogWrite(pinMotor, vitesse);
      }
    else if (distance > 45)
    {
      analogWrite(pinMotor, vitesse-50);
      }
    }
    else
    {
      setColor(0, 0, 255);
      analogWrite(pinMotor, 0);
    }
  }
}

// Fonction pour lire la distance avec le capteur ultrason
long getDistance()
{
    digitalWrite(trigPin, LOW);
    delayMicroseconds(2);
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);

    long duration = pulseIn(echoPin, HIGH);
    long distance = (duration / 2.0) * 0.0344;
    return distance;
}

void setColor(unsigned int red, unsigned int green, unsigned int blue)
{
    red = map(red, 0, 255, 255, 0);
    green = map(green, 0, 255, 255, 0);
    blue = map(blue, 0, 255, 255, 0);
    analogWrite(LED_R, red);
    analogWrite(LED_G, green);
    analogWrite(LED_B, blue);
}

void send_info(){
  unsigned long currentMillisInfo = millis();
  if (currentMillisInfo - lastSend > 2000) {
    espSerial.write("piece");
    Serial.println("piece");
    lastSend = currentMillisInfo;
  }
}

   
void interrupt_routine() {
    unsigned long currentMillis = millis();
    detachInterrupt(digitalPinToInterrupt(pinStart)); 
    if (currentMillis - lastInterrupt > 200) { // anti-rebond 100ms
      is_on = digitalRead(pinStart);
      lastInterrupt = currentMillis;
    }
   attachInterrupt(digitalPinToInterrupt(pinStart), interrupt_routine, CHANGE);
}
              </code></pre>
            </details>


          <h3 id="5-conv">5. Tests fonctionnels</h3>
            <p>
              Le Convoyeur 2.0 a √©t√© soumis √† une s√©rie de tests pour v√©rifier le bon fonctionnement de l‚Äôensemble du syst√®me.
              <br>
              Ci-dessous quelques tests √©ffectu√©s:
            </p>
            <h4>Test de la pupitre de commande</h4>
              <details class="code-container">
                <summary>test_pupitre.ino</summary>
                <div class="btn-bar">
                  <button onclick="copierCode('test_pupitre-ino', this)">üìã</button>
                  <button onclick="telechargerCode('test_pupitre-ino', 'test_pupitre.ino', 'text/ino', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="test_pupitre-ino">
#define pinStart 2
#define LED_R 9
#define LED_G 10
#define LED_B 11

unsigned long lastInterrupt = 0;
volatile bool is_on = false;

// variables pour gestion du timing
unsigned long previousMillis = 0;
int colorState = 0;
const unsigned long interval = 2000; // intervalle de 2 secondes

void setup()
{
  Serial.begin(9600);
    pinMode(LED_R, OUTPUT);
    pinMode(LED_G, OUTPUT);
    pinMode(LED_B, OUTPUT);
    setColor(0, 0, 0); // √©teint la LED

    pinMode(pinStart, INPUT);
    attachInterrupt(digitalPinToInterrupt(pinStart), interrupt_routine, CHANGE);
    delay(500);
    is_on = digitalRead(pinStart);
    Serial.println(is_on);
}

void loop() {
    unsigned long currentMillis = millis();

    if (is_on) {
        if (currentMillis - previousMillis >= interval) {
            previousMillis = currentMillis;

            // changer la couleur en fonction de colorState
            switch(colorState) {
                case 0:
                    setColor(250, 0, 0); // rouge
                    break;
                case 1:
                    setColor(0, 250, 0); // vert
                    break;
                case 2:
                    setColor(0, 0, 250); // bleu
                    break;
            }

            colorState++;
            if (colorState > 2) colorState = 0;
        }
    } else {
        setColor(0, 0, 0); // LED √©teinte
        previousMillis = currentMillis; // r√©initialiser le timing
        colorState = 0;
    }
}

void setColor(unsigned int red, unsigned int green, unsigned int blue)
{
    red = map(red, 0, 255, 255, 0);
    green = map(green, 0, 255, 255, 0);
    blue = map(blue, 0, 255, 255, 0);
    analogWrite(LED_R, red);
    analogWrite(LED_G, green);
    analogWrite(LED_B, blue);
}

void interrupt_routine() {
    unsigned long currentMillis = millis();
    detachInterrupt(digitalPinToInterrupt(pinStart)); 
    if (currentMillis - lastInterrupt > 200) { // anti-rebond 100ms
      is_on = digitalRead(pinStart);
      Serial.println(is_on);
      lastInterrupt = currentMillis;
    }
  attachInterrupt(digitalPinToInterrupt(pinStart), interrupt_routine, CHANGE);
}
                </code></pre>
              </details>
            <video controls width=25%>
              <source src="../videos/TRC25/Convoyeur/test_pupitre.mp4" type="video/mp4">
              Votre navigateur ne supporte pas la vid√©o HTML5.
            </video>

            <h4>Test du moteur et des capteurs</h4>
              <details class="code-container">
                <summary>test_moteur_capteurs.ino</summary>
                <div class="btn-bar">
                  <button onclick="copierCode('test_moteur_capteurs-ino', this)">üìã</button>
                  <button onclick="telechargerCode('test_moteur_capteurs-ino', 'test_moteur_capteurs.ino', 'text/ino', this)">ü°á</button>
                </div>
                <pre><code class="hljs" id="test_moteur_capteurs-ino">
#define pinStart 2

// Contr√¥le moteur
#define pinMotor 3

// D√©finir les broches du capteur de couleur
#define LED_R 9
#define LED_G 10
#define LED_B 11

// capteur infrarouge
#define infraredSensor 8

// capteur Ultrason
#define trigPin 6
#define echoPin 5


unsigned long distance = 0, lastInterrupt = 0;
bool finTapis = true;
volatile bool is_on = false;
const int vitesse = 100;

void setup()
{
    // Moteur
    pinMode(pinMotor, OUTPUT);
    analogWrite(pinMotor, 0); // arr√™t initial

    // LED
    pinMode(LED_R, OUTPUT);
    pinMode(LED_G, OUTPUT);
    pinMode(LED_B, OUTPUT);
    setColor(0, 0, 0); // blanc

    // Ultrason
    pinMode(trigPin, OUTPUT);
    pinMode(echoPin, INPUT);

    // Infrarouge
    pinMode(infraredSensor, INPUT);

    // interrupteur √† bascule
    pinMode(pinStart, INPUT);
    attachInterrupt(digitalPinToInterrupt(pinStart), interrupt_routine, CHANGE);

    Serial.begin(9600);
    delay(1000);
    is_on = digitalRead(pinStart);
}


void loop()
{
  if (!is_on)
  {
    // led en rouge pour indiquer que le syst√®me est en stop
    setColor(255, 0, 0);
    analogWrite(pinMotor, 0);
    while (!is_on)
    {      
      delay(100);
    }
  }
  else
  {
    //setColor(0, 0, 255); 
    //delay(200);
    // distance de l'objet par rapport au capteur
    distance = getDistance();
    int infraredValue = digitalRead(infraredSensor);

    if (infraredValue)
    {
        finTapis = true;
        analogWrite(pinMotor, 0);
        setColor(255, 255, 0);
    }

    else if (distance < 50 || !finTapis)
    {
      if(distance < 15){
        delay(500);
      }
      else if(15 < distance && distance < 20){
          finTapis = false;
        }
        setColor(0, 255, 0);
        analogWrite(pinMotor, vitesse);
        delay(100);
    }
    else
    {
        setColor(0, 0, 255);
        // arr√™t du moteur
        analogWrite(pinMotor, 0);
    }
  }
}

// Fonction pour lire la distance avec le capteur ultrason
long getDistance()
{
    digitalWrite(trigPin, LOW);
    delayMicroseconds(2);
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);

    long duration = pulseIn(echoPin, HIGH);
    long distance = (duration / 2.0) * 0.0344;
    return distance;
}

void setColor(unsigned int red, unsigned int green, unsigned int blue)
{
    red = map(red, 0, 255, 255, 0);
    green = map(green, 0, 255, 255, 0);
    blue = map(blue, 0, 255, 255, 0);
    analogWrite(LED_R, red);
    analogWrite(LED_G, green);
    analogWrite(LED_B, blue);
}

  
void interrupt_routine() {
    unsigned long currentMillis = millis();
    detachInterrupt(digitalPinToInterrupt(pinStart)); 
    if (currentMillis - lastInterrupt > 200) { // anti-rebond 100ms
      is_on = digitalRead(pinStart);
      lastInterrupt = currentMillis;
    }
  attachInterrupt(digitalPinToInterrupt(pinStart), interrupt_routine, CHANGE);
}
                </code></pre>
              </details>
            <video controls width=auto>
              <source src="../videos/TRC25/Convoyeur/test_moteur_capteurs.mp4" type="video/mp4">
              Votre navigateur ne supporte pas la vid√©o HTML5.
            </video>

            <p class="txt_center">
              <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/TRC25/b2ms_Convoyeur/b2ms_Conv_Code.zip" target="_blank" class="download-link">
                T√©l√©charger b2ms_Conv_Code.zip
              </a>
            </p>

        </div>
      </section>
    </main>
  </div>

  <footer>
    Copyright ¬© 2025 Team B2MS CleanTech. All rights reserved.
  </footer>

  <script src="../scripts/script_commun.js"></script>
  <script src="../scripts/script_code.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</body>
</html>
