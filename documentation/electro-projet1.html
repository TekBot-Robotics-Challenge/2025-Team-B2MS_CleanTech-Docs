<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css"
    />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles/style-commun.css" />
  <link rel="stylesheet" href="../styles/style-code.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/srcery.min.css">
  <link rel="icon" type="image/x-icon" href="../logo/favicon.ico">
  <title>D√©partement √âlectronique</title>
</head>
<body>
  <header class="header">
    <div class="section__container header__container_domaine">
      <h2>D√©partement √âlectronique</h2>
    </div>
  </header>

  <div class="layout-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="sidebar-toggle" id="sidebarToggle">
        <i class="fas fa-bars"></i>
      </div>

      <nav class="main-nav">
        <a href=".././" class="nav-link"><i class="fas fa-home"></i> Accueil</a>

        <div class="nav-section">
          <a href="./it" class="nav-link"><i class="fas fa-desktop"></i> IT</a>
          <a href="./electronique" style="text-decoration: none;"><button class="tab-button active"><i class="fas fa-microchip"></i> √âlectronique</button> </a>       
          
          <div class="sub-links">
            <a href="./electro-projet1" class="subtab-button active">Projet 1</a>

            <nav class="project-subnav active" id="subnav-test1">
              <a href="#1-test1">1. Contexte et objectifs</a>
              <a href="#2-test1">2. Choix du capteur</a>
              <a href="#3-test1">3. Principe de fonctionnement</a>
              <a href="#4-test1">4. Sch√©ma √©lectronique sous KICAD</a>
              <a href="#5-test1">5. Codage</a>
              <a href="#6-test1">6. Conception et d√©monstration</a>
              <a href="#7-test1">7. Remarques</a>
              <a href="#8-test1">8. Conclusion</a>
            </nav>

            <a class="subtab-button" href="./electro-projet2">Projet 2</a>
            <a class="subtab-button" href="./electro-projet3">Projet 3</a>
          </div>
        </div>

        <a href="./mecanique" class="nav-link"><i class="fas fa-cogs"></i> M√©canique</a>
        <a href="./convoyeur" class="nav-link"></i><i class="fas fa-forward"></i> Convoyeur</a>
        <a href="./trc25" class="nav-link"><i class="fas fa-robot"></i> TRC25</a>
      </nav>
    </div>

    <!-- Contenu principal -->
    <main class="main-content">
      <section id="electro-content" class="tab-content active">

        <div id="test1" class="subtab-content active">
          <h2 id="projet1" class="projet-titre">Projet 1 - Gyroscope et Acc√©l√©rom√®tre MPU6050</h2>

          <h3 id="1-test1">1. Contexte et objectifs:</h3>
          <p>
            Les donn√©es de navigation telles que la direction et l'acc√©l√©ration sont essentielles dans la conception d‚Äôun robot.
            Ce projet utilise un module MPU6050, combinant un gyroscope et un acc√©l√©rom√®tre, pour mesurer l‚Äôorientation et les mouvements.
          </p>
          <p>
            Ce projet a pour objectif de :
          </p>
          <ul>
            <li>Comprendre le fonctionnement d‚Äôun capteur inertiel (IMU).</li>
            <li>afficher en temps r√©el les directions (haut, bas, gauche, droite) ainsi que les donn√©es d‚Äôacc√©l√©ration sur un √©cran LCD.</li>
            <li>Utiliser le protocole de communication I2C.</li>
            <li>Appliquer les bonnes pratiques de conception logicielle (structure modulaire, classes bien d√©finies, etc.).</li>
          </ul>

          <h3 id="2-test1">2. Choix du capteur : MPU6050</h3>

          <p>
           Le <strong>MPU6050</strong> est un capteur IMU (Inertial Measurement Unit) 6 axes qui combine :
            <ul>
            <li>Un acc√©l√©rom√®tre 3 axes</li>
            <li>Un gyroscope 3 axes</li>
            </ul>
          </p>
        
          <p>
            Il utilise une interface I2C, parfaitement compatible avec les
            microcontr√¥leurs comme l‚ÄôArduino, ce qui facilite la lecture des
            donn√©es avec un minimum de fils et une consommation r√©duite.
          </p>

          <p>
            Il est largement utilis√© dans la communaut√© Arduino, avec de
            nombreuses biblioth√®ques disponibles (comme MPU6050.h ou
            Wire.h), ce qui simplifie le d√©veloppement et le d√©bogage
          </p>

          <p>
          <strong>Caract√©ristiques principales</strong> : <a href="https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf" download class="download-link">datasheet du MPU6050</a>
            <ul>
            <li>Interface I2C (adresse par d√©faut : `0x68`)</li>
            <li>Plage de mesure acc√©l√©rom√®tre : ¬±2g, ¬±4g, ¬±8g, ¬±16g</li>
            <li>Tension d‚Äôalimentation : 3.3V ‚Äì 5V</li>
            </ul>
            
          </p>
          

        <h3 id="3-test1">3. Principe de fonctionnement</h3>
            <p>
             Le capteur MPU6050 combine deux fonctions principales : un acc√©l√©rom√®tre et un gyroscope.
            L‚Äôacc√©l√©rom√®tre permet de mesurer l‚Äôacc√©l√©ration lin√©aire sur les trois axes (X, Y, Z), ce qui
            permet de d√©tecter les mouvements de la main vers le haut, le bas, la gauche, la droite, l‚Äôavant
            ou l‚Äôarri√®re. De son c√¥t√©, le gyroscope mesure la vitesse angulaire sur ces m√™mes axes, ce qui
            permet de conna√Ætre l‚Äôorientation de la main, comme une inclinaison ou une rotation.
          </p>

          <p>
           Pour transmettre les donn√©es au microcontr√¥leur, le MPU6050 utilise le protocole de
            communication I2C. Ce protocole est simple et efficace, car il ne n√©cessite que deux fils : la
            ligne SCL (pour l‚Äôhorloge) et la ligne SDA (pour les donn√©es). Gr√¢ce √† cette liaison, le
            microcontr√¥leur peut envoyer des commandes au capteur et lire ses valeurs en temps r√©el.
          </p>

          <p>
           Pour que le MPU6050 envoie les donn√©es, il ne suffit pas
          de simplement le connecter. √âtant donn√© qu‚Äôon utilise
          une communication I2C, il faut suivre un protocole bien
          d√©fini :
          </p>

          <h4>a. Envoi d‚Äôune commande au capteur</h4>
  
            <p>
            Avant de lire une donn√©e, l‚ÄôArduino doit envoyer l‚Äôadresse du registre souhait√©. Cette adresse indique quel type de
              donn√©e on veut (acc√©l√©ration, vitesse angulaire)
            </p>

            <div class="image-container">
              <img src="../images/Test1/Electronique/registre_electronique1.webp" alt="Registre" class="image-centree" />
            </div>
            <div class="image-container">
              <img src="../images/Test1/Electronique/registre_electronique2.webp" alt="Registre" class="image-centree" />
            </div>

          <h4>b. Structure des donn√©es re√ßues</h4>

            <p>
              Chaque mesure (acc√©l√©ration ou rotation) est cod√©e sur 16 bits (2 octets) :  
            </p>
              <ul>
              <li>8 bits MSB (poids fort)</li>
              <li>8 bits LSB (poids faible)</li>
            </ul> 
            <p>
              Les valeurs sont en compl√©ment √† deux (signed integer), ce qui permet d'indiquer un sens positif ou n√©gatif du mouvement. 
            </p>

          <h4>c. Conversion des donn√©es brutes</h4>
  
            <p>
            Pour exploiter les mesures, il faut les convertir en unit√©s physiques :
            </p>
            <ul>
              <li> Acc√©l√©ration en g (gravit√© terrestre)</li>
              <li> Rotation en ¬∞/s (degr√©s par seconde)</li>
            </ul> 

            <div class="image-container">
              <img src="../images/Test1/Electronique/converesion_electro1.webp" alt="Conversion" class="image-centree" />
            </div>
            <div class="image-container">
              <img src="../images/Test1/Electronique/converesion_electro2.webp" alt="Conversion" class="image-centree" />
            </div>

          
          <h3 id="4-test1">4. Sch√©ma √©lectronique sous KICAD</h3>
          <div class="image-container">
            <img src="../images/Test1/Electronique/schema_electro.webp" alt="Sch√©ma √©lectronique sous KICAD" class="image-centree" />
          </div>

          <h3 id="5-test1">5. Codage</h3> 
          <h4>a. Code 1: </h4> 
            <p>
              Ce code utilise la librairie MPU6050 sur Arduino IDE.
            </p>
  
            <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('code_mpu1-ino', this)">üìã</button>
                <button onclick="telechargerCode('code_mpu1-ino', 'code_mpu1.ino', 'text/ino', this)">ü°á</button>
              </div>
              <pre><code class="hljs" id="code_mpu1-ino">
#include &lt;Wire.h&gt;               // Biblioth√®que pour communication I2C
#include &lt;LiquidCrystal_I2C.h&gt;  // Biblioth√®que pour √©cran LCD I2C
#include &lt;MPU6050.h&gt;            // Biblioth√®que pour capteur MPU6050

// Initialisation √©cran LCD avec adresse I2C 0x27, 16 colonnes et 2 lignes
LiquidCrystal_I2C lcd(0x27, 16, 2);

// Cr√©ation instance MPU6050
MPU6050 mpu;

// Variables pour stocker l'acc√©l√©ration en g (gravit√©)
float ax, ay, az;

// Norme totale de l'acc√©l√©ration (valeur absolue)
float accel_norm;

// Seuil d'acc√©l√©ration (en g) pour d√©tecter un mouvement significatif
const float threshold = 0.2;

void setup() {
  Serial.begin(9600);  // Initialisation communication s√©rie √† 9600 bauds (pour debug √©ventuel)
  Wire.begin();        // Initialisation bus I2C

  lcd.init();          // Initialisation √©cran LCD
  lcd.backlight();     // Allumer r√©tro√©clairage LCD

  // Initialisation MPU6050
  mpu.initialize();

  // V√©rification de la connexion avec MPU6050
  if (!mpu.testConnection()) {
    lcd.print("MPU6050 error"); // Affiche erreur si capteur non d√©tect√©
    while (1);                  // Bloque le programme ici (boucle infinie)
  }

  lcd.clear();
  lcd.print("MPU6050 OK"); // Confirmation que capteur est pr√™t
  delay(1000);
  lcd.clear();
}

void loop() {
  // Variables pour stocker les valeurs brutes (raw) lues depuis MPU6050
  int16_t rawAx, rawAy, rawAz;

  // Lecture des valeurs d'acc√©l√©ration brute sur 3 axes
  mpu.getAcceleration(&rawAx, &rawAy, &rawAz);

  // Conversion des valeurs brutes en unit√©s g (gravit√©)
  // Selon datasheet, la sensibilit√© est 16384 LSB/g en mode ¬±2g
  ax = rawAx / 16384.0;
  ay = rawAy / 16384.0;
  az = rawAz / 16384.0;

  // Calcul de la norme de l'acc√©l√©ration totale vectorielle
  // sqrt(x¬≤ + y¬≤ + z¬≤) -> donne l'intensit√© totale ressentie
  accel_norm = sqrt(ax * ax + ay * ay + az * az);

  // D√©tection de la direction dominante en fonction du seuil
  String direction = "";    // Texte √† afficher (direction d√©tect√©e)
  if (ax > threshold) { 
    direction = "Gauche";   // Si acceleration sur axe X positive > seuil
  }
  else if (ax < -threshold) {
    direction = "Droite";   // Si acceleration sur axe X n√©gative < -seuil
  }
  else if (ay > threshold) {
    direction = "Arriere";  // Si acceleration sur axe Y positive > seuil
  }
  else if (ay < -threshold) {
    direction = "Avant";    // Si acceleration sur axe Y n√©gative < -seuil
  }
  else if (az > threshold) {
    direction = "Haut";      // Si acceleration sur axe Z positive > seuil
  }
  else if (az < -threshold) {
    direction = "Bas";       // Si acceleration sur axe Z n√©gative < -seuil
  }
  else {
    direction = "Stable";    // Si aucune acceleration significative d√©tect√©e
  }

  // Affichage sur l'√©cran LCD
  lcd.clear();              // Efface l'√©cran √† chaque boucle
  lcd.setCursor(0, 0);      // Position curseur ligne 0, colonne 0
  lcd.print("Dir: ");       // Affiche label "Direction"
  lcd.print(direction);     // Affiche la direction d√©tect√©e

  lcd.setCursor(0, 1);      // Position curseur ligne 1, colonne 0
  lcd.print("Accel: ");     // Affiche label "Acc√©l√©ration"
  lcd.print(accel_norm, 2); // Affiche la norme de l'acc√©l√©ration avec 2 d√©cimales
  lcd.print(" g");          // Affiche unit√© g (gravit√©)

  delay(300);               // Pause de 300 ms avant prochaine lecture
}
              </code></pre>
              </div>


          <h4>b. Code 2: </h4> 
            <p>
              Ce code n'utilise pas la librairie MPU6050 sur Arduino IDE.
            </p>

            <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('code_mpu2-ino', this)">üìã</button>
                <button onclick="telechargerCode('code_mpu2-ino', 'code_mpu2.ino', 'text/ino', this)">ü°á</button>
              </div>
              <pre><code class="hljs" id="code_mpu2-ino">
#include &lt;Wire.h&gt;               // Biblioth√®que pour la communication I2C
#include &lt;LiquidCrystal_I2C.h&gt;      // Biblioth√®que pour g√©rer l'√©cran LCD I2C

const int MPU = 0x68;                // Adresse I2C du capteur MPU6050 (valeur par d√©faut)

LiquidCrystal_I2C lcd(0x27, 16, 2); // Initialisation de l'√©cran LCD I2C (adresse 0x27, 16 colonnes, 2 lignes)

// Variables pour stocker les donn√©es d'acc√©l√©ration
float AccX, AccY, AccZ;
// Variables pour stocker les donn√©es de gyroscope
float GyroX, GyroY, GyroZ;

// Angles calcul√©s √† partir de l'acc√©l√©rom√®tre
float accAngleX, accAngleY;
// Angles calcul√©s √† partir du gyroscope (int√©gr√©s)
float gyroAngleX, gyroAngleY, gyroAngleZ;

// Angles fusionn√©s (roll, pitch, yaw)
float roll, pitch, yaw;

// Erreurs calcul√©es lors de la calibration (offsets √† enlever)
float AccErrorX, AccErrorY, GyroErrorX, GyroErrorY, GyroErrorZ;

// Variables pour g√©rer le temps √©coul√© entre deux mesures
float elapsedTime, currentTime, previousTime;

// Compteur utilis√© pour la calibration
int c = 0;

void setup() {
  Serial.begin(19200);         // Initialisation du port s√©rie √† 19200 bauds pour debug
  Wire.begin();                // D√©marrage de la communication I2C

  // R√©veil du MPU6050 qui est en veille par d√©faut
  Wire.beginTransmission(MPU); // D√©marrer la transmission vers MPU
  Wire.write(0x6B);            // Registre PWR_MGMT_1 (gestion alimentation)
  Wire.write(0x00);            // Mettre √† 0 pour sortir du mode veille
  Wire.endTransmission(true);  // Fin de la transmission

  // Initialisation de l'√©cran LCD
  lcd.begin(16, 2);            // D√©finir taille LCD (16x2)
  lcd.backlight();             // Activer r√©tro√©clairage
  lcd.setCursor(0, 0);         // Positionner curseur au d√©but ligne 0
  lcd.print("Initialisation..."); // Message de d√©marrage
  delay(1000);                 // Pause d'1 seconde
  lcd.clear();                 // Effacer √©cran

  // Calibration automatique du capteur (calcul des erreurs √† soustraire)
  calculate_IMU_error();
  delay(20);                   // Petite pause
}

void loop() {
  // === Lecture des valeurs brutes de l'acc√©l√©rom√®tre ===
  Wire.beginTransmission(MPU);
  Wire.write(0x3B);                    // Adresse du registre de d√©but des donn√©es Accel
  Wire.endTransmission(false);        // Garder la communication ouverte
  Wire.requestFrom(MPU, 6, true);     // Lire 6 octets (2 par axe X,Y,Z)

  // Conversion des donn√©es brutes en valeurs en g (gravit√©)
  AccX = (Wire.read() << 8 | Wire.read()) / 16384.0; // Acc√©l√©ration X
  AccY = (Wire.read() << 8 | Wire.read()) / 16384.0; // Acc√©l√©ration Y
  AccZ = (Wire.read() << 8 | Wire.read()) / 16384.0; // Acc√©l√©ration Z

  // Calcul des angles d'inclinaison (roll, pitch) avec acc√©l√©rom√®tre
  accAngleX = (atan(AccY / sqrt(pow(AccX, 2) + pow(AccZ, 2))) * 180 / PI) - AccErrorX;
  accAngleY = (atan(-AccX / sqrt(pow(AccY, 2) + pow(AccZ, 2))) * 180 / PI) - AccErrorY;

  // === Lecture des valeurs brutes du gyroscope ===
  previousTime = currentTime;           // Sauvegarde du temps pr√©c√©dent
  currentTime = millis();                // Temps actuel en ms
  elapsedTime = (currentTime - previousTime) / 1000;  // Temps √©coul√© en secondes

  Wire.beginTransmission(MPU);
  Wire.write(0x43);                    // Adresse du registre de d√©but des donn√©es Gyro
  Wire.endTransmission(false);        // Garder la communication ouverte
  Wire.requestFrom(MPU, 6, true);     // Lire 6 octets (2 par axe X,Y,Z)

  // Conversion des donn√©es brutes en degr√©s/seconde
  GyroX = (Wire.read() << 8 | Wire.read()) / 131.0;
  GyroY = (Wire.read() << 8 | Wire.read()) / 131.0;
  GyroZ = (Wire.read() << 8 | Wire.read()) / 131.0;

  // Soustraction des erreurs calcul√©es lors de la calibration
  GyroX = GyroX - GyroErrorX;
  GyroY = GyroY - GyroErrorY;
  GyroZ = GyroZ - GyroErrorZ;

  // Int√©gration des vitesses angulaires pour obtenir les angles
  gyroAngleX += GyroX * elapsedTime;
  gyroAngleY += GyroY * elapsedTime;
  yaw += GyroZ * elapsedTime;

  // Application d'un filtre compl√©mentaire pour combiner acc√©l√©rom√®tre et gyroscope
  // On donne plus de poids au gyroscope (0.96) car plus pr√©cis sur court terme
  // L'acc√©l√©rom√®tre corrige la d√©rive du gyroscope sur le long terme (0.04)
  roll = 0.96 * gyroAngleX + 0.04 * accAngleX;
  pitch = 0.96 * gyroAngleY + 0.04 * accAngleY;

  // === D√©tection simple de la direction du mouvement en fonction des angles ===
  String direction = "haut"; // Valeur par d√©faut

  if (roll < -40 ) direction = "Avant";
  else if (roll < 80 && roll > 60) direction = "Arriere";
  else if (pitch > 15) direction = "Droite";
  else if (pitch < -15) direction = "Gauche";
  else if (pitch > 30) direction = "Haut";
  else if (pitch > 120 && roll > 100) direction = "Bas";

  // === Affichage de la direction d√©tect√©e sur l'√©cran LCD ===
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Direction:");
  lcd.setCursor(0, 1);
  lcd.print(direction);

  // Affichage des angles pour debug sur moniteur s√©rie
  Serial.print("Roll: "); Serial.print(roll);
  Serial.print(" | Pitch: "); Serial.print(pitch);
  Serial.print(" | Yaw: "); Serial.println(yaw);

  delay(300); // Pause avant prochaine lecture
}

// === Fonction pour calibrer automatiquement le capteur au d√©marrage ===
void calculate_IMU_error() {
  // Calibration acc√©l√©rom√®tre : moyenne des angles calcul√©s sur plusieurs mesures
  while (c < 200) {
    Wire.beginTransmission(MPU);
    Wire.write(0x3B);
    Wire.endTransmission(false);
    Wire.requestFrom(MPU, 6, true);

    AccX = (Wire.read() << 8 | Wire.read()) / 16384.0;
    AccY = (Wire.read() << 8 | Wire.read()) / 16384.0;
    AccZ = (Wire.read() << 8 | Wire.read()) / 16384.0;

    // Calcul des angles roll et pitch √† partir de l'acc√©l√©rom√®tre
    AccErrorX += atan(AccY / sqrt(pow(AccX, 2) + pow(AccZ, 2))) * 180 / PI;
    AccErrorY += atan(-AccX / sqrt(pow(AccY, 2) + pow(AccZ, 2))) * 180 / PI;

    c++;
  }
  // Moyenne des erreurs calcul√©es
  AccErrorX /= 200;
  AccErrorY /= 200;
  c = 0; // R√©initialisation compteur

  // Calibration gyroscope : moyenne des valeurs lues au repos
  while (c < 200) {
    Wire.beginTransmission(MPU);
    Wire.write(0x43);
    Wire.endTransmission(false);
    Wire.requestFrom(MPU, 6, true);

    GyroX = Wire.read() << 8 | Wire.read();
    GyroY = Wire.read() << 8 | Wire.read();
    GyroZ = Wire.read() << 8 | Wire.read();

    GyroErrorX += GyroX / 131.0;
    GyroErrorY += GyroY / 131.0;
    GyroErrorZ += GyroZ / 131.0;

    c++;
  }
  // Moyenne des erreurs gyroscopiques
  GyroErrorX /= 200;
  GyroErrorY /= 200;
  GyroErrorZ /= 200;

  // Affichage des r√©sultats de calibration dans le moniteur s√©rie
  Serial.println("Calibration Terminee:");
  Serial.print("AccErrorX: "); Serial.println(AccErrorX);
  Serial.print("AccErrorY: "); Serial.println(AccErrorY);
  Serial.print("GyroErrorX: "); Serial.println(GyroErrorX);
  Serial.print("GyroErrorY: "); Serial.println(GyroErrorY);
  Serial.print("GyroErrorZ: "); Serial.println(GyroErrorZ);
}
              </code></pre>

            </div>


          <h3 id="6-test1">6. Conception d'un prototype et d√©monstration</h3>
          
          <div class="image-container">
            <img src="../images/Test1/Electronique/electronique1.webp" alt="Prototype" class="image-small" />
            <img src="../images/Test1/Electronique/electronique2.webp" alt="Prototype" class="image-small" />
            <img src="../images/Test1/Electronique/electronique3.webp" alt="Prototype" class="image-small" />
            <img src="../images/Test1/Electronique/electronique4.webp" alt="Prototype" class="image-small" />
          </div>

          <video controls width=auto>
            <source src="../videos/Test1/Electronique/final_trial.mp4" type="video/mp4">
            Votre navigateur ne supporte pas la vid√©o HTML5.
          </video>

          <video controls width=auto>
            <source src="../videos/Test1/Electronique/prototype.mp4" type="video/mp4">
            Votre navigateur ne supporte pas la vid√©o HTML5.
          </video>

          <h3 id="7-test1">7. Remarques</h3>
            <ul>
            <li>
              Pour des lectures plus stables et pr√©cises, il est possible d'int√©grer
              un filtre compl√©mentaire ou un filtre de Kalman.</li>
            <li>
              Ce projet constitue une excellente base pour des syst√®mes plus avanc√©s,
              tels que les contr√¥leurs, les robots auto-√©quilibr√©s ou les plateformes de stabilisation.</li>
          </ul> 
          
    
        <h3 id="8-test1">8. Conclusion</h3>
          <p>
            Ce projet nous a permis d‚Äôexplorer l‚Äôint√©gration d‚Äôun capteur inertiel dans un syst√®me embarqu√©, ainsi que de mettre en ≈ìuvre la d√©tection
            et l‚Äôaffichage en temps r√©el des mouvements de la main.
          </p>
           
          <p>
            Le module MPU6050 s‚Äôest r√©v√©l√© √™tre un outil efficace et accessible
            pour la d√©tection de l‚Äôorientation et des mouvements.
          </p>

          <p>
            Gr√¢ce √† sa compatibilit√© avec l‚Äô√©cosyst√®me Arduino et √† la disponibilit√© de biblioth√®ques
            d√©di√©es, le MPU6050 peut √™tre facilement int√©gr√© dans divers projets √©ducatifs ou de prototypage.
          </p>

          <p>
            L‚Äôaffichage des directions d√©tect√©es et des valeurs d‚Äôacc√©l√©ration sur un √©cran LCD 16x2
            offre une visualisation claire et p√©dagogique, id√©ale pour l‚Äôapprentissage des capteurs,
            de la programmation de microcontr√¥leurs et des interfaces homme-machine.
          </p>      
          
          <p>
            Au-del√† de son int√©r√™t p√©dagogique, ce syst√®me peut √™tre √©tendu √† des applications telles
            que le contr√¥le par gestes, la r√©alit√© virtuelle ou la robotique, avec la possibilit√©
            d‚Äôajouter une communication Bluetooth ou Wi-Fi pour renforcer l‚Äôinteractivit√©.
          </p>      
        </div>

      </section>
    </main>
  </div>

  <footer>
    Copyright ¬© 2025 Team B2MS CleanTech. All rights reserved.
  </footer>

  <script src="../scripts/script_commun.js"></script>
  <script src="../scripts/script_code.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</body>
</html>
